Mobile -Smart Phones - 2005

web client ------------------------>Webservice
  Apps-require data<--------------------XML--fall of XML Based webservices......

Different data format
very light weight data format
only http as core transport
  -RESTFull webservice - Roy fielding.

JSON...........

DATA DRIVEN DRIVEN SERVERS----WEB SERVER ONLY RETURNS DATA IN form of json or xml ....


dynamic content web app - talks to data base directly

dynamic content web app (USER interface) - webservice----talks to data base


dynamic content web app (USER interface) - server side (php,asp.net,servlets/jsp)
          |
 
client-1-------webserver--prepare html page

client-1000-----webserver---prepare html for 1000 clients.........



SPA - Spec introduced by w3c AS PART OF HTML 5 Spec

 Building USER interface apps using javascript at client side instead of server side...

dynamic content web app (USER interface) -preparing html pages at client side  - client side (js) -----webservice---datasource..


FULL Stack?

one language one framework building - 

Dynamic web app model

 aspx -----V
 M/C ----c# 

react/ng/vue ---view---------> java/.net/php/python etc...

react--------------------|...net

react-front end
react also back end ->Full stack.

React extended to act as back end and front end 

Using react you can create webservices...
Using react you can generate html pages at both server and client

NEXT.JS => React framwork which extends react for server and client..


NEXT JS
  ->SPA at client
  ->SSR AT Server side - Full SSR..


=>Full Stack apps: =>Full SSR(Next.js)
   Using react like apps are built using full stack apps=>Next js

....................................................................................
			 HTML Prepartion


static sites:
1.Hard coded html page preparation by hand - first generation technology...

pros:
 ->It is super fast.
cons:
  Hard coded html pages are really hard.
  Page update is really very hard.

Dynamic sites:

 Prepare html pages dynamically--- via Special programs-(java,.net)

When the pages are prepared?

 => when client requests , server receives requests , then prepares HTML Pages.- DCGT
pros:
 ->page is prepared dynamically so that your app is live..
 ->Always we get latest information.

cons:
 ->web server load would be heavy, webserver may receives 1000's of requests which degrades performances.
  Thats where SPA Were created...BUT SPA has its own drawbacks....

i want to prepare html pages dynamically at server , but 
  ->i need performance
  ->i need client side interactions like spa...

High Performance + SPA => JAMSTACK

 => "During BUILD PHASE" - SSG - Static Site Generation.

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.
.....................................................................................
			  Rendering
			    |
	-----------------------------------------------------------
      CSR                                               SSR
						         |
					-------------------------------------
					Request           build time    build+request
					 |                |             |
				      Full SSR            SSG           ISR

NEXT Supports all types of rendering, you can mix and match based on your app use cases......


can you run e6 module keywords directly inside node.js

util.js

export const name='google'

index.js

import {name} from './util.js'
console.log(name)

node index.js

two config

package.json

 "type" :"module"

or
util.mjs -module js - understood by node...


How to start dev server

> npm run dev


component hierachy in react:

Normal Composition:

const Hello =()=><h1>Hello</h1>
const Greeter = ()=><Hello/>

const App=()=> <Greeter />


Component as props and compostion:

const Hello =()=><h1>Hello</h1>
const Greeter = ()=> {props.children}

const App=()=> <Greeter>
   <Hello/>
 </Greeter>
 

component hiearch in next

const Layout =(props)=><html>
	<body>{props.children}</body>
 </html>

page.js
 const Page=()=><div></div>

<Layout>
    <Page/>
</Layout>



runtime -  js engine - v8, 
	   nodejs

js code:

  object
     ->data
     ->methods


objects are hosted inside runtime in a heap memory

obj.mymethod()=>stack=>frame is created

when you call method more times in the same sequence....


object.mymethod() --stack-frame is created ->10
object.mymethod() --stack-frame is created
object.mymethod()--stack-frame is created
object.mymethod()--stack-frame is created

What if a method returns same result again and again.

object.mymethod() --stack-frame is created ->10 -12
object.mymethod() --stack-frame is created ->10
object.mymethod()--stack-frame is created-->10
object.mymethod()--stack-frame is created-->10

what is caching?
  Caching is tech through which you can store fun returned value in memory,
 when next method invocation , we dont need to create frame rather return that value from cache.

React hooks:

1.useState
2.useEffect

.............

revalidation:
 Clear the cache- delete entries from the cache.

caching:
server

 -function calls -for creating components 

const Welcome=()=>useMemo(<h1>Hello</h1>)

<Welcome/>
<Welcome/>
<Welcome/>
<Welcome/>

data cache
  fetch('/api/todos') -> hits api server-get data- stores data in cache
  fetch('/api/todos') - take data from cache
  fetch('/api/todos') - take data from cache

Full Route cache
   Page rendering - create html- cache it
  if you ask the same page again-take from cache

client side: 
  router cache..
..............

caching can happen during request time or build time.

SSG:
 During build--pages are cached

after build, if user gives request---->gets that page from cache....

after build, if your gives request, what if there is data change,---we cant get from cache-- we need to rerender(recreate page) ->ISR

During request time- pages cached

Caching terminallogy:

MISS :
    If requested item is not in cache

SET:
   STORE THE REQUESTED ITEM INTO CACHE

HIT:
   if requested item in the cache.


request memoziation and fetch request:
........................................

/a
tree
  |
 layout
    fetch -----miss-hit-set

   nested layout

  page
     fetch - hit
   
   component-1
       fetch - hit

   |
   tree is rendered-
     memory is reset

/a

Request Memoization is applied for "REST APIS"-ROUTE HANDLER
  only for component tree.


Data cache:
 It is memory where you can cache data of next application

 fetch('/api/todos')=> [{}] ->store in cache

 in order to set data into data cache  using fetch, we dont need to write any code.
 fetch has been extended to add those behaviour automatically. 


Data cache reavalidation:
 clearning


Revalidation:
 How to clear data cache?

->Types of revalidation
  - Time based Revalidation.
       i want to clear data cache,lets say after or every 1 min.

->On-demand Revalidation.
   - Clear the cache manually or based on some event..
     eg: Using external api , after form submission..

 Two way of on-demand revalidation
    Tag-based revalidation
    path-based revalidation

Time based revalidation:
  we can implement in two ways

1.In fetch api
2.Route Segment Config options

fetch api:
..........
fetch('url',options)
fetch('http://...',{next:{revalidate:3600}})

2.Route Segement config options

 Setting configuration parameters  inside code(layout,page,routeHander(fetch))
 setting configuration parameter as by declaring variables.

 eg:
   export const variableName=value
  
   export const revalidate=3600

page.js

export const revalidate=3600

export async function fetchProducts(){
   
    //const response = await fetch('url');
     const response = await fetch('url',{next:{revalidate:2000}});
}
 
export default function ProductPage(){

   return <>


   </>
}

On-Deman Revalidation:
  based on tag 
  based on path

fetch api:
..........
fetch('url',options)
fetch('http://...',{next:{tags:['a']})
 
Opting out:to choose not to participate in

https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control

fetch('http://...', {cache:'no-store'})
   -Dont store this fetch response into cache. always you have to hit datasource.

opting out can be implemented
 1.inside fetch 
 2.via route segment config options
   export const dynamic='auto'

...................
Full Route Cache:
  Cache pages either in build time or request time.

Rendering is spilt into chunks(parts)
   by route segment
   by suspense boundary.

chunk is rendered in two steps:

  Server components - converted into a special format - RSC Payload.
    RSC payload looks like json format.

RSC:
 ->Binary representation of rendered react server compoent.
 ->It is used by React on the client side to update browser's dom

RSC Has:
  -rendered(page) result of server compoent
  -place holder for client component and there js references
  -any props passed from server compoent to client compoent.

................................................................................

Client Side: Router Cache:
............................
RSC Payload stored inside browser - under Router Cache.
Router cache is used to improve performance of navigation
   ->previously visited routes
   ->Prefetching future routes

Router cache only caches "static route"
Router cache dont cache  "dynamic route"

invalidation:
 ->Page refresh
 ->time based
    static rendered page: 5 mins
    dynamically rendered page:30 secs

.....................................................................................

Dynamic rendering:
  -request time

dynamic functions:
  functions which trigger dynamic rendering.

dynamic rendering can be triggered by "data change in the api" or dynamic functions.

->coookies
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
			ISR - Caching,revalidation
....................................................................................










