Mobile -Smart Phones - 2005

web client ------------------------>Webservice
  Apps-require data<--------------------XML--fall of XML Based webservices......

Different data format
very light weight data format
only http as core transport
  -RESTFull webservice - Roy fielding.

JSON...........

DATA DRIVEN DRIVEN SERVERS----WEB SERVER ONLY RETURNS DATA IN form of json or xml ....


dynamic content web app - talks to data base directly

dynamic content web app (USER interface) - webservice----talks to data base


dynamic content web app (USER interface) - server side (php,asp.net,servlets/jsp)
          |
 
client-1-------webserver--prepare html page

client-1000-----webserver---prepare html for 1000 clients.........



SPA - Spec introduced by w3c AS PART OF HTML 5 Spec

 Building USER interface apps using javascript at client side instead of server side...

dynamic content web app (USER interface) -preparing html pages at client side  - client side (js) -----webservice---datasource..


FULL Stack?

one language one framework building - 

Dynamic web app model

 aspx -----V
 M/C ----c# 

react/ng/vue ---view---------> java/.net/php/python etc...

react--------------------|...net

react-front end
react also back end ->Full stack.

React extended to act as back end and front end 

Using react you can create webservices...
Using react you can generate html pages at both server and client

NEXT.JS => React framwork which extends react for server and client..


NEXT JS
  ->SPA at client
  ->SSR AT Server side - Full SSR..


=>Full Stack apps: =>Full SSR(Next.js)
   Using react like apps are built using full stack apps=>Next js

....................................................................................
			 HTML Prepartion


static sites:
1.Hard coded html page preparation by hand - first generation technology...

pros:
 ->It is super fast.
cons:
  Hard coded html pages are really hard.
  Page update is really very hard.

Dynamic sites:

 Prepare html pages dynamically--- via Special programs-(java,.net)

When the pages are prepared?

 => when client requests , server receives requests , then prepares HTML Pages.- DCGT
pros:
 ->page is prepared dynamically so that your app is live..
 ->Always we get latest information.

cons:
 ->web server load would be heavy, webserver may receives 1000's of requests which degrades performances.
  Thats where SPA Were created...BUT SPA has its own drawbacks....

i want to prepare html pages dynamically at server , but 
  ->i need performance
  ->i need client side interactions like spa...

High Performance + SPA => JAMSTACK

 => "During BUILD PHASE" - SSG - Static Site Generation.

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.
.....................................................................................
			  Rendering
			    |
	-----------------------------------------------------------
      CSR                                               SSR
						         |
					-------------------------------------
					Request           build time    build+request
					 |                |             |
				      Full SSR            SSG           ISR

NEXT Supports all types of rendering, you can mix and match based on your app use cases......


can you run e6 module keywords directly inside node.js

util.js

export const name='google'

index.js

import {name} from './util.js'
console.log(name)

node index.js

two config

package.json

 "type" :"module"

or
util.mjs -module js - understood by node...


How to start dev server

> npm run dev


component hierachy in react:

Normal Composition:

const Hello =()=><h1>Hello</h1>
const Greeter = ()=><Hello/>

const App=()=> <Greeter />


Component as props and compostion:

const Hello =()=><h1>Hello</h1>
const Greeter = ()=> {props.children}

const App=()=> <Greeter>
   <Hello/>
 </Greeter>
 

component hiearch in next

const Layout =(props)=><html>
	<body>{props.children}</body>
 </html>

page.js
 const Page=()=><div></div>

<Layout>
    <Page/>
</Layout>



runtime -  js engine - v8, 
	   nodejs

js code:

  object
     ->data
     ->methods


objects are hosted inside runtime in a heap memory

obj.mymethod()=>stack=>frame is created

when you call method more times in the same sequence....


object.mymethod() --stack-frame is created ->10
object.mymethod() --stack-frame is created
object.mymethod()--stack-frame is created
object.mymethod()--stack-frame is created

What if a method returns same result again and again.

object.mymethod() --stack-frame is created ->10 -12
object.mymethod() --stack-frame is created ->10
object.mymethod()--stack-frame is created-->10
object.mymethod()--stack-frame is created-->10

what is caching?
  Caching is tech through which you can store fun returned value in memory,
 when next method invocation , we dont need to create frame rather return that value from cache.

React hooks:

1.useState
2.useEffect

.............

revalidation:
 Clear the cache- delete entries from the cache.

caching:
server

 -function calls -for creating components 

const Welcome=()=>useMemo(<h1>Hello</h1>)

<Welcome/>
<Welcome/>
<Welcome/>
<Welcome/>

data cache
  fetch('/api/todos') -> hits api server-get data- stores data in cache
  fetch('/api/todos') - take data from cache
  fetch('/api/todos') - take data from cache

Full Route cache
   Page rendering - create html- cache it
  if you ask the same page again-take from cache

client side: 
  router cache..
..............

caching can happen during request time or build time.

SSG:
 During build--pages are cached

after build, if user gives request---->gets that page from cache....

after build, if your gives request, what if there is data change,---we cant get from cache-- we need to rerender(recreate page) ->ISR

During request time- pages cached

Caching terminallogy:

MISS :
    If requested item is not in cache

SET:
   STORE THE REQUESTED ITEM INTO CACHE

HIT:
   if requested item in the cache.


request memoziation and fetch request:
........................................

/a
tree
  |
 layout
    fetch -----miss-hit-set

   nested layout

  page
     fetch - hit
   
   component-1
       fetch - hit

   |
   tree is rendered-
     memory is reset

/a

Request Memoization is applied for "REST APIS"-ROUTE HANDLER
  only for component tree.


Data cache:
 It is memory where you can cache data of next application

 fetch('/api/todos')=> [{}] ->store in cache

 in order to set data into data cache  using fetch, we dont need to write any code.
 fetch has been extended to add those behaviour automatically. 


Data cache reavalidation:
 clearning








