				Next js
.....................................................................................

What is a Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".

Web Applications:
.................

What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document.
=>HTML
 
other responses types
XML,JSON,Documents,images,vidoes.........


What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.

The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html.

Types of Web application:

1.Static web applications - 1989 to 1995 (Now a days also people are building this type apps)
   Hard coded html pages , prepared html pages  kept at webserver , the webserver will send those html pages to clients(browsers)


2.Dynamic Content generation application(1996 to till date)

  After 1995, many people thought that how we can use web for biz information system

 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.

3.Web services-1998 to till date

 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.

 We need to data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...



4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js
.....................................................................................
			  React as SPA lib
.....................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.

Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

The brith of new Technology called  "SSR" -  Server Side Rendering:
..................................................................................
 I need SEO but at the same time, i want to use SPA as well.

We provides first class api to "render"  an SPA app into HTML strings on the server.
This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.

.....................................................................................
			SSR types

Server side Rendering(preparation -Page Preparation(html))
-HTML is prepared at client side only- pure spa
-HTML is prepared at server and client - SSR


=>Partil SSR 
     We have SPA already, but only few pages(index.html) page is pre compiled at server and sent to client , from where client apps(spa) starts working.

Generally React has api called "ReactDOMServer" using this api we have to render html page on node js(express/hapi)
 
=>Full SSR
     Every thing is compiled at server side , where as client logics like api calls using ajax , user interactions like form submission,ui animations, is done at client side once the app is rendered.


SSG/JAMStack: (Static Site Generation)
......................................

What is Jamstack?
Jamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.

Jamstack removes the need for business logic to dictate the web experience.

Just sending HTML pages to the client without preparing htmls pages while requesting.



SSR will prepare html at server side during "request-response  phase/cycle"

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.

....................................................................................

client------------request----------------server---prepares page(production)

dev--source code-----push --- build stage----prepares the app---push into production server --100 page1.html.....page100.html

client------------request ------------------server --- prepared page

ssg.

Once the app in production, what if there is data change,then app is already prepared and kept production.

what if  the updated data we need in pages?

  => We need to rebuild the whole app
      once the app in production, if there is new build, we need to stop existing app in production, we need to redeploy the app


 =>ISR - Incremental Static Rendering

  SSG - Build time
  SSR - Request time
  SSG+SSR = build time+request time = ISR

....................................................................................
			   Next js  -SSR and SSG
.....................................................................................

Next js is full stack web framwork built on the top of react core features  to build modern SSG and SSR apps at very fast...


Next js Architecture:
...........................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming langugage, used to build Nextjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 17x faster than Babel, it is embeded inside next js
....................................................................................
		NEXT JS Getting Started
.....................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 16.8 or later
2.OS - any os
3.vs code.

npx create-next-app@latest

E:\session\TADigital>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.1.0
Ok to proceed? (y) y
√ What is your project named? ... my-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\my-app.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss


added 137 packages, and audited 138 packages in 14s

33 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Initialized a git repository.

Success! Created my-app at E:\session\TADigital\my-app


E:\session\TADigital>cd my-app

E:\session\TADigital\my-app>code .
.....................................................................................
			 Project Structure
.....................................................................................
package.json

{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.1.0"
  },
  "devDependencies": {
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0"
  }
}
scripts:
 dev: runs next dev to start next.js in development mode
 build: runs next build to build the application for production usage
 start: runs next start to start a next apps in production mode.
 lint: runs next lint to set up next built in eslint configuration.


next.config.mjs 

/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

	It helps to configure next js server infrastructure....


compiler configuration:
jsconfig.json

{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

tailwind configuration: (css configuration)
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};

postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


public:
  stores static assests such images,fonts,documents
  public dir are accessed inside code using the base URL "/".


src/app 
  Where application code is available....
  
 layout.js
 page.js
 global.css
Note: which is similar to index.js and App.js in react.
.....................................................................................
			Next app is conventional over configuration
.....................................................................................

                    "In next every folder and files are pre defined"


In next there is no predefined index.html file, because index.html is generated by next server during request time or build time.

File Names:
1.page.js
2.layout.js

 Theses files names are predefined file names , we cant change file names as we wish.

files has been designed based on conventional over configuration, meaning every file has meaning.

page.js
  It is holding user interface , if the page.js is part of "src/app/" folder which is root file(index.html) called landing page.

layout.js
  It is going to hold root layout, which is required in next js.

Every next application must have this "src/app/layout.js" file.


What is inside these files?
   React component.

Page Component - page.js
layout Component -layout.js
.....................................................................................
			  React core features inside next js
....................................................................................

1.Component
  In React every thing component, in next also the component dirven arch is followed.

2.Props
  In react data is passed to components via props.

 -data as prop
 -state as prop- dynamic prop
 -function as prop-listener as prop
 -component as prop.

In next we use Component as Prop syntax heavily.

 const Tab = props=>{

    return <>
	{props.children}
   <>
 }

 <Tab/> - self closing

 <Tab>
    <Panel>
</Tab>

3.state 
   How to declare client side state 

4.hooks
   Nextjs uses only uses hooks heavily

5.No class components
   Next js deprecated class compoents , only functional function components

6.Less useage/No use age of Redux
  Since we are building ssr application, the scope of redux is very very limited.

7.Should use always "export default" , no export for next components
.....................................................................................

		   Every thing is a component is next js

layout.js :
  It is container component, which renders Page(rootPage). - Component as prop



layout.js
export default function RootLayout(props) {

  return (
    <html lang="en">
      <body>{props.children}</body>
    </html>
  );

}

1.every function must be exported using "export default" only
2.Since it is root index page, it should return <html>
3.It should have body , inside we should props.children
4.function name is not reserved or built in name , you can name it any name.

src/app/page.js
//page is component which holds the root page or index.


export default function HomePage() {

  return <div>
     <h1>Welcome to TADigital</h1>
  </div>
}

1.every function must be exported using "export default only"
2.It should return home page content.
3.It will inserted into layout automatically.

File Conventions:

 Next.js provides a set of special files to create APP.
 Each File has specific meaning

layout.js 
  Shared UI For a segment and its children.
  if layout.js present inside src/app folder which is called root layout.
  Every Next.js app must have one layout.js which is root layout file.

nestedlayout
  layout.js
   Shared UI For a segment and its children.
   when you define routing , that means folder src/app/products,you can have    layout.js which defines the nested layout, that means , the layout inside another    layout
 
Note: root layout is going to have root html content.
      sub/nested layouts would have div element.

eg:
 <html>
  <head> 
    <title>This is my page</title>
  </head>
  <body>
	<HomePage>
	<div> -->Nested layout..
  </body>   
 </html>

2.page.js
   Unique UI of a route, meaning the page is mapped against routing like / - index, /products

3.loading.js
   Loading UI (Spinner) for a segement and its children

4.not-found.js
   Not Found UI for a segement and its children
   if routing is failed to map against a page, then next.js will show error page.
5.error.js
    it is used to show custom compoent logic errors.
    
6.global-error 
  error.js
   if you define error handler globally, it is called global error page.

Note: 
  All error  files are represented by "React ErrorBoundary"

7.route.js
   You can write "RESTFull WebService"

8.template.js
   Specialized re-rendered Layout UI.

9.default.js
   Fallback UI for "Parrel Routes"


Note:
 When we write next application, every thing is component
  Error is component
  Loading is Compoent
  Page is component
  Layout is compoent.

Since Everything is compoent , which forms component hierachy.

React dev tool can used to look into the component hiearchy....

Using react dev tool we can look , next application....


Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
.....................................................................................				 Layouts and Routing & Pages
				Routing
.....................................................................................

Routing:
  The skeleton of every next application is routing.

 Inside the app directory, "folders" are used to define routes

src/app/ ----- index route/home route

Each folder represents a "route segment" that maps to a "URL" segement. in order to created route you can nest folders inside each other

URL Pattern:

localhost:3000 /    
	       |
            Root segment

Segment means part of url.


localhost:3000 /     dashboard /settings
		       |            |              
	Root segment  Segment   leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

if you different name other than page.js , it will not be available for public access.

 app/dashboard/config/myconfig.js

http://localhost:3000/dashboard/config/myconfig - It will throw error.

Lab:
 How to create nested route

src/app/hello/page.js  ===> http://localhost:3000/hello
 
folder name becomes the url name.

http://localhost:3000/hello , it maps against page.js

src/app/hello/page.js

export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}


What if i have folder, but no page.js,

src/app/hello == http://localhost:3000/hai

 if no page.js found, then it will throw "404 Page Not Found" , that means next automatically fallback to "ErrorBoundary" , it maps against default notfound.js message.


Layouts and Pages:

1.Every next app must have root layout.
2.you can define nested layout to share for a segment.

Lab:
 I want to define a layout for hello and hai separtelly.

src/app/hello/layout.js

export default function HelloLayout({ children }) {
    return <div id="hellolayout">
        {children}
    </div>
}

src/app/hello/page.js

export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}

http://localhost:3000/hello

<div id="rootlayout">
   <div id="hellolayout">
     <div id="HelloPage">
      <h1>Hello Page</h1>
	</div>
     </div>
</div>

Deep Nesting:
.............
src/app/greet/welcome/hello

src/app/greet/layout.js

export default function GreetLayout({ children }) {
    return <div id="greetLayout">
        {children}
    </div>
}
src/app/greet/page.js
export default function GreetPage() {
    return <div id="GreetPage">
        <h1>Greet Page</h1>
    </div>
}

src/app/greet/welcome/layout.js

export default function WelcomeLayout({ children }) {
    return <div id="welcomeLayout">
        {children}
    </div>
}
src/app/greet/welcome/page.js

export default function WelcomePage() {
    return <div id="welcome">
        <h1>Welcome Page</h1>
    </div>
}

src/app/greet/welcome/hello/layout.js

XXXXXX

src/app/greet/welcome/hello/page.js
        
export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}

As of now we have discussed basic routing 
  =>Index route
  =>Nested Route
  =>Deep Nested Route
  =>Root layout and nested layouts

We will explore advanced routing patterns
.............................................................................................
			     Compoent Types && Rendering Types
............................................................................................

Rendering is nothing but page prepartion (html creation)

How to create html and where to create html?

Where:
 Rendering can take place on the server or on the client.

When:
At Server Side:
  It can happen either ahead of time at build time, 
  or on every request at runtime. 

With Next. js, three types of rendering methods are available
  
1.Server-Side Rendering, 
  1.0. Request time
  1.1. Static Site generation
  1.2. ISR - Incremental static rendering = Build time + runtime

3.Client-Side Rendering
   Preparing portion of page at client side. which is similar to SPA applications


Component types:
 Based on Rendering we can classlify the components into two category

 1.Server components 
    Components are rendered at server side 
 2.Client components 
   Components are rendered at client side 

   By default all components are "Server rendered Components".

Page,layouts,templates,errors,notfound,loading,default all are server compoents by default.
............................................................................................
			  Client Components
.............................................................................................

Generally React application is component driven.
Component which may have logic to interact with user, like button clicks,typing, animations,
that means any dom manipulation.

Co-location:
  Apart from the special files you can co-locate , other files such as components,css,test files,utility files within app folder or subfolder/nested folder.
eg: 
src/app/review/like.jsx

Can i write state mutations inside next, like react using hooks?

Yes.

src/app/review/like.jsx

export const Like = props => {
    return <div>
        <h1>Like</h1>
    </div>
}


src/app/review/page.js

import { Like } from "./like"

export default function ReviewPage() {
    return <div id="rootPage">
        <h1>Review Page</h1>
        <Like />
    </div>
}

The above code ReviewPage has Like component

 <ReviewPage>
	<Like/>
 </Review>

Adding Button and useState Hook, Listener:
..........................................

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    return <div>
        <h1>Like {like}</h1>
    </div>
}

After adding this code, next compiler throws an error:

× You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
  │ Learn more: https://nextjs.org/docs/getting-started/react-essentials
  │
  │
   ╭─[E:\session\TADigital\my-app\src\app\review\like.jsx:1:1]
 1 │ import { useState } from "react"
   ·          ────────
 2 │
 3 │ export const Like = props => {
 3 │     const [like, setLike] = useState(0)


Why this error?
  
 Server not able render the above code, the reason is the code is subject browser rendering that means, client side rendering.


in order to compile we need to use directive , called "use client"

soultion:

"use client"

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

Why client Rendering? Benefits of Client Rendering:
...................................................

1.Interactivity:
  Client Components can use useState,useEffect,event listeners, meaning that they can provide immediate feedback to the user and update the UP

2.Browser Api
   Clients components can access browser apis like, geolocation, or localStorage allowing you to build UI for specific use cases
.............................................................................................
			 Patterns for client and server compoents

1.Server component uses client compoents
2.Client component uses another Server Components
3.Client uses another Client Components


1.Server component uses client compoents
  
Client:
 src/app/review/review.jsx

"use client"

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}
Server:
src/app/review/page.jsx
import { Like } from "./like"

export default function ReviewPage() {
    console.log('Review Page')
    return <div id="rootPage">
        <h1>Review Page</h1>
        <Like />
    </div>
}

Note:
 if server uses client , the client component must be marked with "use client" directive
..............................................................................................

2.Client uses another Server component:

   if client uses Server,Server Component automatically becomes client component
   This pattern is not recommended, because we loose server rendering feature

src/app/review/myreivew.jsx

"use client"

import { useState } from "react"
//user server component
import { Dislike } from "./dislike"

export const MyReview = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
        <Dislike />
    </div>
}

src/app/review/dislike.jsx

export const Dislike = props => {
    console.log('dislike')
    return <div>
        <h1>DisLike</h1>
    </div>
}

What if client uses server component but at the same time, i dont want loose server rendering feature?

Yes , You can
  Pass Server Component as prop to child Component

<Client>
	<Server/>
</Client>

steps:
src/app/client/page.js


import MyClient from "./myclient"
import MyServer from "./myserver"

export default function ClientPage() {
    return <div>
        <h1>Client Page</h1>
        {/* <MyClient /> */}
        {/* Pass Server compoent as prop to Child Compoent */}
        <MyClient>
            <MyServer />
        </MyClient>
    </div>
}

src/app/client/myserver.jsx
//server compoent
export default function MyServer() {

    return <div>
        <h1>Server Component</h1>
    </div>
}

src/app/client/myclient.jsx

"use client"
// import MyServer from "./myserver"

export default function MyClient(props) {

    return <div>
        <h1>Client Component</h1>
        {/* <MyServer /> */}
        {props.children}
    </div>
}
............................................................................................
3.Client uses another Client compoent
......................................

Client can uses another client


src/app/likes/page.js
import { MyReview } from "./review"

export default function LikePage() {
    return <div>
        <h1>Like and Dislike Page</h1>
        <MyReview />
    </div>
}

Client Compoenent uses another client called "like.jsx"
src/app/likes/myreview.jsx

'use client'

import { Like } from "./like"

export const MyReview = props => {
    return <>
        <Like></Like>
    </>
}

src/app/likes/like.jsx

'use client'
import { useState } from "react"

export const Like = () => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if client uses another client component, the another component need not use "use client" directive.

src/app/likes/like.jsx


// 'use client'
import { useState } from "react"

export const Like = () => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

When this pattern will be very usefull?

You are building web app using next, there would be an use case that you want to use third party ui libs like gridcompoents,tabs.......

By default all third party react components are client components,
......................................&&&&&&&&&&&&&&&&........................................
				Advanced Routing
.....................................................................................

>npx create-next-app@latest
√ What is your project named? ... advanced-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\advanced-routing.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

....................................................................................
				Linking and Navigating
...................................................................................


				Redirection Patterns

1.redirect api:
............
The redirect is the function allows you to redirect the user to another url.

Purpose:
  Redirect uses after a mutation or event
Where:
  Server Components, Server Actions,Route Handlers

Status Code:
 307 - Temp
 303 - Server Actions

Syntax:
export default function update(){
  //update logic
  //update logic is success or failure
  redirect('url') //navigate to the new page
}
Note: this will discuss later when write api handlers and server actions...


2.permanentRedirect:
  It is similar to redirect, but the status would be 308


3.useRouter:
   Client Side Navigation 

4.redirects in next.config.js:
/** @type {import('next').NextConfig} */
const nextConfig = {
    async redirects() {
        return [
            //basic redirection
            {
                source: '/about',
                destination: '/',
                permanent: true
            },
            {
                source: '/myproducts',
                destination: '/products',
                permanent: true
            }
        ]
    }

};

export default nextConfig;

5.NextResponse.redirect:
   Inside Middlewares

.....................................................................................

Client side navigation
 userRouter,Link,History api
Server side navigation
 redirect,PermanentRedirect,routeConfig in next.js,
 Api redirections -NextResponse.redirect



Client Side Navigation:
......................
There are three ways to navigate between routes in Next.js

1.Using <Link> Component
2.Using useRouter hook
3.Using the native history API (browser api)

Note:
  Next js provides lot of in built components

Built in Components:
1.Link
2.Font
3.Image
4.Script

Link:<Link> 

=>Enables fast client-side navigation.
=>It extends the HTML <a> element to provide prefetching and client navigation between routes
=>Link is part of the pacakge called 'next/Link'

Link Props:

1.href - url pattern
2.replace
3.scroll
4.prefetch

Syntax:
 href value can be string or object

<Link href="/customer">Customer</Link>

<Link href={{pathname:'/customer',query: {city:'coimbatore'}}}>Customer</Link>


Note:  

 if you want to share nav bar, site footer across the application, you have to write nav bar inside root layout.

src/app/layout.js
import Link from "next/link";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <h1>My Commerce</h1>
        <hr />
        <nav>
          <Link href={{ pathname: '/customer' }}>Customer</Link> |
          <Link href={{ pathname: '/products' }}>Products</Link>
        </nav>
        {children}
      </body>
    </html>
  );
}

src/app/customer/page.js
export default function CustomerPage() {
    return <>
        <h2>Customer Page</h2>
    </>
}
src/app/customer/layout.js
export default function CustomerLayout({ children }) {
    return <div id="customerlayout">
        {children}
    </div>
}

src/app/product/page.js
export default function ProductPage() {
    return <>
        <h2>Product Page</h2>
    </>
}
...............................................................................
			Code Refactoring

As much as possible we can design ui based on component driven arch,that means spilt the components.

src/app/Footer.jsx

export default function Footer() {
    return <>
        <div>
            <p>Site footer</p>
        </div>
    </>
}
src/app/navbar.jsx
import Link from 'next/link'
export default function NavBar() {
    return <nav>
        <Link href={{ pathname: '/customer' }}>Customer</Link> |
        <Link href={{ pathname: '/products' }}>Products</Link>
    </nav>
}
src/app/Header.jsx

export default function Header() {
    return <>
        <h1>My Commerce</h1>
        <hr />
    </>

}
src/layout.js
import Footer from "./Footer";
import Header from "./Header";
import NavBar from "./navbar";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Header />
        <NavBar />
        {children}
        <Footer />
      </body>
    </html>
  );
}
.....................................................................................
			useRouter Hook
.....................................................................................

useRouter hook allows you programmatically change routes from Client Compoents.
redirect method is used to change routes in Server Components


src/app/dashboard/Nav.jsx

'use client'
import { useRouter } from "next/navigation"

export default function Nav() {
    const router = useRouter()
    return <>
        <div>
            <button onClick={() => {
                router.push('/customer')
            }}>Customer</button>
            <button onClick={() => {
                router.push('/products')
            }}>Product</button>
        </div>

    </>
}
src/app/dashboard/page.js
import Nav from './Nav'
export default function Dashboard() {
    return <>
        <h1>Dashboard</h1>
        <Nav />
    </>
}

src/app/navbar.jsx
import Link from 'next/link'
export default function NavBar() {
    return <nav>
        <Link href={{ pathname: '/customer' }}>Customer</Link> |
        <Link href={{ pathname: '/products' }}>Products</Link> |
        <Link href={{ pathname: '/dashboard' }}>Dashboard</Link>
    </nav>
}
....................................................................................
			  Browser history api
....................................................................................

We can use browser's history api.

window.history.pushState  === router.push

Since we are using next router apis, we dont need to use raw browser apis

Note: Recommended is to use Next router apis
.....................................................................................
			Advanced Routing - Dynamic Routes
.....................................................................................

>npx create-next-app@latest
√ What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\dynamic-routes.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss


What is dynamic route?
	When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.


Convention:
  A Dynamic Segment can be created by wrapping a folder's name in square brackets:    [folderName].
   For example, [id] or [slug].

  Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions..

Use case:
 if you want to build master detail Page.

Master
src/app/profiles/page.js

Details
src/app/profiles/[id]/page.js
                  |
               place holder


URL Pattern:

http://localhost:3000/profiles/1

src/app/
      profiles
	|
        page.js
        layout.js
      [id]
         page.js
         layout.js

src/app/profiles/page.js

export default function Home() {
    return <h1>
        Profile Page
    </h1>
}

src/app/profiles/[id]/page.js

export default function ProfileDetailsPage() {
    return <div>
        <h1>Profile Details</h1>
    </div>
}

How to access Path parameters inside  Details Page?

via props

props.params =>{"id":"2"}

eg:

// export default function ProfileDetailsPage(props) {
//     return <div>
//         {/* <h1>Profile Details {JSON.stringify(props)}</h1> */}
//         <h1>{props.params.id} details</h1>
//     </div>
// }

export default function ProfileDetailsPage({ params: { id } }) {
    return <div>
        {/* <h1>Profile Details {JSON.stringify(props)}</h1> */}
        <h1>{id} details</h1>
    </div>
}
.....................................................................................
		    Master Details Page Preparation using Mock Data
.....................................................................................

Steps:

1.Have some mock data
 src/app/mock-data/todos.js - Refer code

2.Have Master page
 src/app/todos/page.js
import Link from "next/link";
import { TODOS } from "../mock-data/todos";

export default function TodosMasterPage() {
    return <>
        <h1>Todos Master Page</h1>
        {/* Prepare dynamic menu */}
        <ul>
            {
                TODOS.map(todo => {
                    return <li>
                        <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}
3.Have details Page
 src/app/todos/[id]/page.js
export default function TodosDetailsPage({ params: { id } }) {
    return <div>
        <h1>{id} details</h1>
    </div>
}
.....................................................................................
		    Master Details Page Preparation using API calls
.....................................................................................

In Next js api calls are made using "fetch" api by default.
fetch is promised powered , when ever or where you call fetch api , you can use async await keywords.

server component functions, apis can be marked as async keyword.

eg
src/app/posts/page.js ->Master page.

import Link from "next/link";

export async function fetchPosts() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts')
    const posts = await response.json()
    //here we return promise
    return posts;
}

export default async function PostsPage() {
    const posts = await fetchPosts()
    return <>
        <h1>Posts Master Page</h1>
        {/* Prepare dynamic menu */}
        <ul>
            {
                posts.map(post => {
                    return <li>
                        <Link href={`/posts/${post.id}`}>{post.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/posts/[id]/page.js
export default function PostsDetailsPage({ params: { id } }) {
    return <div>
        <h1>{id} details</h1>
    </div>
}

Assignment:
 Make an api call in  the details to fetch particular post and fill it.
....................................................................................
		        Advanced Routing-Dynamic Routes
			   Catch-all Segment Routing
...................................................................................

Dyamic segments can be extended to catch all subsequent segements by adding [...slug]

eg:

without catchall

  shop
   |
   [a]
    |
     page.js  /shop/a
   |
   [b]
     |
     page.js /shop/a/b
    |
    [c]
     |
      page.js  /shop/a/c



with catch all
 shop
  |
   page.js
  
  [...slug]
     |
   page.js

Eg:
 /shop/tops
 /show/tops/tshirt
 /show/dress/men/shirt
  
How to capture paramers
 {
   slug: ['tops','tshirt','men,'shirt']
 }

EG:
 src/app/shop/page.js

export default function ShopPage() {
    return <>
        <h1>Shop Page</h1>
    </>
}
src/app/shop/[...slug]/page.js

export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page {JSON.stringify(params)}</h1>
    </>
}
Url Pattern:
http://localhost:3000/shop/cloths/tops/t-shirts

Response:
Shop Details Page {"slug":["cloths","tops","t-shirts"]}

....................................................................................
		        Advanced Routing-Dynamic Routes
		        Optional Catch-all Segment Routing
...................................................................................

shop
  |
   page.js
  
  [...slug]
     |
   page.js

let us assume that, if you want to show shop, /shop we need page.js inside shop folder.

With Optional Catch all:
........................

shop
  |
  [[...slug]]
     |
   page.js

eg:

src/app/shop/[[...slug]]/page.js

export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page {JSON.stringify(params)}</h1>
    </>
}

Testing:
http://localhost:3000/shop
Response
Shop Details Page {}

http://localhost:3000/shop/cloths/tops
Response
Shop Details Page {"slug":["cloths","tops"]}
....................................................................................
		        Advanced Routing- Parallel Routes		     
...................................................................................

What is Parallel Route?

Generally inside a layout, we render only one page by default.

What if i want to render "Mutiple Pages" inside single layout simultaneously or conditionally.

"Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.For highly dynamic sections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns"


Single Page within layout : Component View:
...........................................
<Layout>
     <Page/>
</Layout>

Multiple pages within Single Layout: Component View

<Layout>
  <PageOne/>
  <PageTwo/>
</Layout>

What if i want to render page conditionally? Conditional Rendering

<Layout>
    {condtion ? <ThisPage/> : <ThatPage/>}
</Layout>

Basic Structure:

 src/app
     |
     layout.js -root layout
     page.js  -root page
   |
   info
     |
     layout.js -info layout
     page.js  - info page

Here, only info page is inserted into info layout
now I want to display two pages called team and analytics within info layout.

npx create-next-app@latest
√ What is your project named? ... parallel-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\parallel-routing.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

Steps:

1.src/app/game/layout.js
export default function GameLayout(props) {
    return <div id="gamelayout">
        {props.children}
    </div>
}
2.src/app/game/page.js

export default function GamePage() {
    return <div>
        <h1>Game Page</h1>
    </div>
}

3.Parralel Routing, we need to create folder with following syntax

@FolderName
   |
  page.js
  layout.js

src/app/game/@team/page.js
export default function TeamPage() {
    return <div>
        <h1>Team Page</h1>
    </div>
}
Now if you test
http://localhost:3000/game/team
 The output would be page not found, the reason is you cant access team page publicily
team page must be injected into "Games layout as prop".









