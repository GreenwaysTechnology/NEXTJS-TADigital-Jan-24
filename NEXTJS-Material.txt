				Next js
.....................................................................................

What is a Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".

Web Applications:
.................

What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document.
=>HTML
 
other responses types
XML,JSON,Documents,images,vidoes.........


What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.

The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html.

Types of Web application:

1.Static web applications - 1989 to 1995 (Now a days also people are building this type apps)
   Hard coded html pages , prepared html pages  kept at webserver , the webserver will send those html pages to clients(browsers)


2.Dynamic Content generation application(1996 to till date)

  After 1995, many people thought that how we can use web for biz information system

 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.

3.Web services-1998 to till date

 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.

 We need to data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...



4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js
.....................................................................................
			  React as SPA lib
.....................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.

Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

The brith of new Technology called  "SSR" -  Server Side Rendering:
..................................................................................
 I need SEO but at the same time, i want to use SPA as well.

We provides first class api to "render"  an SPA app into HTML strings on the server.
This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.

.....................................................................................
			SSR types

Server side Rendering(preparation -Page Preparation(html))
-HTML is prepared at client side only- pure spa
-HTML is prepared at server and client - SSR


=>Partil SSR 
     We have SPA already, but only few pages(index.html) page is pre compiled at server and sent to client , from where client apps(spa) starts working.

Generally React has api called "ReactDOMServer" using this api we have to render html page on node js(express/hapi)
 
=>Full SSR
     Every thing is compiled at server side , where as client logics like api calls using ajax , user interactions like form submission,ui animations, is done at client side once the app is rendered.


SSG/JAMStack: (Static Site Generation)
......................................

What is Jamstack?
Jamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.

Jamstack removes the need for business logic to dictate the web experience.

Just sending HTML pages to the client without preparing htmls pages while requesting.



SSR will prepare html at server side during "request-response  phase/cycle"

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.

....................................................................................

client------------request----------------server---prepares page(production)

dev--source code-----push --- build stage----prepares the app---push into production server --100 page1.html.....page100.html

client------------request ------------------server --- prepared page

ssg.

Once the app in production, what if there is data change,then app is already prepared and kept production.

what if  the updated data we need in pages?

  => We need to rebuild the whole app
      once the app in production, if there is new build, we need to stop existing app in production, we need to redeploy the app


 =>ISR - Incremental Static Rendering

  SSG - Build time
  SSR - Request time
  SSG+SSR = build time+request time = ISR

....................................................................................
			   Next js  -SSR and SSG
.....................................................................................

Next js is full stack web framwork built on the top of react core features  to build modern SSG and SSR apps at very fast...


Next js Architecture:
...........................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming langugage, used to build Nextjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 17x faster than Babel, it is embeded inside next js
....................................................................................
		NEXT JS Getting Started
.....................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 16.8 or later
2.OS - any os
3.vs code.

npx create-next-app@latest

E:\session\TADigital>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.1.0
Ok to proceed? (y) y
√ What is your project named? ... my-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\my-app.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss


added 137 packages, and audited 138 packages in 14s

33 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Initialized a git repository.

Success! Created my-app at E:\session\TADigital\my-app


E:\session\TADigital>cd my-app

E:\session\TADigital\my-app>code .
.....................................................................................
			 Project Structure
.....................................................................................
package.json

{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.1.0"
  },
  "devDependencies": {
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0"
  }
}
scripts:
 dev: runs next dev to start next.js in development mode
 build: runs next build to build the application for production usage
 start: runs next start to start a next apps in production mode.
 lint: runs next lint to set up next built in eslint configuration.


next.config.mjs 

/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

	It helps to configure next js server infrastructure....


compiler configuration:
jsconfig.json

{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

tailwind configuration: (css configuration)
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};

postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


public:
  stores static assests such images,fonts,documents
  public dir are accessed inside code using the base URL "/".


src/app 
  Where application code is available....
  
 layout.js
 page.js
 global.css
Note: which is similar to index.js and App.js in react.
.....................................................................................
			Next app is conventional over configuration
.....................................................................................

                    "In next every folder and files are pre defined"


In next there is no predefined index.html file, because index.html is generated by next server during request time or build time.

File Names:
1.page.js
2.layout.js

 Theses files names are predefined file names , we cant change file names as we wish.

files has been designed based on conventional over configuration, meaning every file has meaning.

page.js
  It is holding user interface , if the page.js is part of "src/app/" folder which is root file(index.html) called landing page.

layout.js
  It is going to hold root layout, which is required in next js.

Every next application must have this "src/app/layout.js" file.


What is inside these files?
   React component.

Page Component - page.js
layout Component -layout.js
.....................................................................................
			  React core features inside next js
....................................................................................

1.Component
  In React every thing component, in next also the component dirven arch is followed.

2.Props
  In react data is passed to components via props.

 -data as prop
 -state as prop- dynamic prop
 -function as prop-listener as prop
 -component as prop.

In next we use Component as Prop syntax heavily.

 const Tab = props=>{

    return <>
	{props.children}
   <>
 }

 <Tab/> - self closing

 <Tab>
    <Panel>
</Tab>

3.state 
   How to declare client side state 

4.hooks
   Nextjs uses only uses hooks heavily

5.No class components
   Next js deprecated class compoents , only functional function components

6.Less useage/No use age of Redux
  Since we are building ssr application, the scope of redux is very very limited.

7.Should use always "export default" , no export for next components
.....................................................................................

		   Every thing is a component is next js

layout.js :
  It is container component, which renders Page(rootPage). - Component as prop



layout.js
export default function RootLayout(props) {

  return (
    <html lang="en">
      <body>{props.children}</body>
    </html>
  );

}

1.every function must be exported using "export default" only
2.Since it is root index page, it should return <html>
3.It should have body , inside we should props.children
4.function name is not reserved or built in name , you can name it any name.

src/app/page.js
//page is component which holds the root page or index.


export default function HomePage() {

  return <div>
     <h1>Welcome to TADigital</h1>
  </div>
}

1.every function must be exported using "export default only"
2.It should return home page content.
3.It will inserted into layout automatically.

File Conventions:

 Next.js provides a set of special files to create APP.
 Each File has specific meaning

layout.js 
  Shared UI For a segment and its children.
  if layout.js present inside src/app folder which is called root layout.
  Every Next.js app must have one layout.js which is root layout file.

nestedlayout
  layout.js
   Shared UI For a segment and its children.
   when you define routing , that means folder src/app/products,you can have    layout.js which defines the nested layout, that means , the layout inside another    layout
 
Note: root layout is going to have root html content.
      sub/nested layouts would have div element.

eg:
 <html>
  <head> 
    <title>This is my page</title>
  </head>
  <body>
	<HomePage>
	<div> -->Nested layout..
  </body>   
 </html>

2.page.js
   Unique UI of a route, meaning the page is mapped against routing like / - index, /products

3.loading.js
   Loading UI (Spinner) for a segement and its children

4.not-found.js
   Not Found UI for a segement and its children
   if routing is failed to map against a page, then next.js will show error page.
5.error.js
    it is used to show custom compoent logic errors.
    
6.global-error 
  error.js
   if you define error handler globally, it is called global error page.

Note: 
  All error  files are represented by "React ErrorBoundary"

7.route.js
   You can write "RESTFull WebService"

8.template.js
   Specialized re-rendered Layout UI.

9.default.js
   Fallback UI for "Parrel Routes"


Note:
 When we write next application, every thing is component
  Error is component
  Loading is Compoent
  Page is component
  Layout is compoent.

Since Everything is compoent , which forms component hierachy.

React dev tool can used to look into the component hiearchy....

Using react dev tool we can look , next application....


Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
.....................................................................................				 Layouts and Routing & Pages
				Routing
.....................................................................................

Routing:
  The skeleton of every next application is routing.

 Inside the app directory, "folders" are used to define routes

src/app/ ----- index route/home route

Each folder represents a "route segment" that maps to a "URL" segement. in order to created route you can nest folders inside each other

URL Pattern:

localhost:3000 /    
	       |
            Root segment

Segment means part of url.


localhost:3000 /     dashboard /settings
		       |            |              
	Root segment  Segment   leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

if you different name other than page.js , it will not be available for public access.

 app/dashboard/config/myconfig.js

http://localhost:3000/dashboard/config/myconfig - It will throw error.

Lab:
 How to create nested route

src/app/hello/page.js  ===> http://localhost:3000/hello
 
folder name becomes the url name.

http://localhost:3000/hello , it maps against page.js

src/app/hello/page.js

export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}


What if i have folder, but no page.js,

src/app/hello == http://localhost:3000/hai

 if no page.js found, then it will throw "404 Page Not Found" , that means next automatically fallback to "ErrorBoundary" , it maps against default notfound.js message.


Layouts and Pages:

1.Every next app must have root layout.
2.you can define nested layout to share for a segment.

Lab:
 I want to define a layout for hello and hai separtelly.

src/app/hello/layout.js

export default function HelloLayout({ children }) {
    return <div id="hellolayout">
        {children}
    </div>
}

src/app/hello/page.js

export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}

http://localhost:3000/hello

<div id="rootlayout">
   <div id="hellolayout">
     <div id="HelloPage">
      <h1>Hello Page</h1>
	</div>
     </div>
</div>

Deep Nesting:
.............
src/app/greet/welcome/hello

src/app/greet/layout.js

export default function GreetLayout({ children }) {
    return <div id="greetLayout">
        {children}
    </div>
}
src/app/greet/page.js
export default function GreetPage() {
    return <div id="GreetPage">
        <h1>Greet Page</h1>
    </div>
}

src/app/greet/welcome/layout.js

export default function WelcomeLayout({ children }) {
    return <div id="welcomeLayout">
        {children}
    </div>
}
src/app/greet/welcome/page.js

export default function WelcomePage() {
    return <div id="welcome">
        <h1>Welcome Page</h1>
    </div>
}

src/app/greet/welcome/hello/layout.js

XXXXXX

src/app/greet/welcome/hello/page.js
        
export default function HelloPage() {
    return <div id="HelloPage">
        <h1>Hello Page</h1>
    </div>
}

As of now we have discussed basic routing 
  =>Index route
  =>Nested Route
  =>Deep Nested Route
  =>Root layout and nested layouts

We will explore advanced routing patterns
.............................................................................................
			     Compoent Types && Rendering Types
............................................................................................

Rendering is nothing but page prepartion (html creation)

How to create html and where to create html?

Where:
 Rendering can take place on the server or on the client.

When:
At Server Side:
  It can happen either ahead of time at build time, 
  or on every request at runtime. 

With Next. js, three types of rendering methods are available
  
1.Server-Side Rendering, 
  1.0. Request time
  1.1. Static Site generation
  1.2. ISR - Incremental static rendering = Build time + runtime

3.Client-Side Rendering
   Preparing portion of page at client side. which is similar to SPA applications


Component types:
 Based on Rendering we can classlify the components into two category

 1.Server components 
    Components are rendered at server side 
 2.Client components 
   Components are rendered at client side 

   By default all components are "Server rendered Components".

Page,layouts,templates,errors,notfound,loading,default all are server compoents by default.
............................................................................................
			  Client Components
.............................................................................................

Generally React application is component driven.
Component which may have logic to interact with user, like button clicks,typing, animations,
that means any dom manipulation.

Co-location:
  Apart from the special files you can co-locate , other files such as components,css,test files,utility files within app folder or subfolder/nested folder.
eg: 
src/app/review/like.jsx

Can i write state mutations inside next, like react using hooks?

Yes.

src/app/review/like.jsx

export const Like = props => {
    return <div>
        <h1>Like</h1>
    </div>
}


src/app/review/page.js

import { Like } from "./like"

export default function ReviewPage() {
    return <div id="rootPage">
        <h1>Review Page</h1>
        <Like />
    </div>
}

The above code ReviewPage has Like component

 <ReviewPage>
	<Like/>
 </Review>

Adding Button and useState Hook, Listener:
..........................................

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    return <div>
        <h1>Like {like}</h1>
    </div>
}

After adding this code, next compiler throws an error:

× You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
  │ Learn more: https://nextjs.org/docs/getting-started/react-essentials
  │
  │
   ╭─[E:\session\TADigital\my-app\src\app\review\like.jsx:1:1]
 1 │ import { useState } from "react"
   ·          ────────
 2 │
 3 │ export const Like = props => {
 3 │     const [like, setLike] = useState(0)


Why this error?
  
 Server not able render the above code, the reason is the code is subject browser rendering that means, client side rendering.


in order to compile we need to use directive , called "use client"

soultion:

"use client"

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

Why client Rendering? Benefits of Client Rendering:
...................................................

1.Interactivity:
  Client Components can use useState,useEffect,event listeners, meaning that they can provide immediate feedback to the user and update the UP

2.Browser Api
   Clients components can access browser apis like, geolocation, or localStorage allowing you to build UI for specific use cases
.............................................................................................
			 Patterns for client and server compoents

1.Server component uses client compoents
2.Client component uses another Server Components
3.Client uses another Client Components


1.Server component uses client compoents
  
Client:
 src/app/review/review.jsx

"use client"

import { useState } from "react"

export const Like = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}
Server:
src/app/review/page.jsx
import { Like } from "./like"

export default function ReviewPage() {
    console.log('Review Page')
    return <div id="rootPage">
        <h1>Review Page</h1>
        <Like />
    </div>
}

Note:
 if server uses client , the client component must be marked with "use client" directive
..............................................................................................

2.Client uses another Server component:

   if client uses Server,Server Component automatically becomes client component
   This pattern is not recommended, because we loose server rendering feature

src/app/review/myreivew.jsx

"use client"

import { useState } from "react"
//user server component
import { Dislike } from "./dislike"

export const MyReview = props => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
        <Dislike />
    </div>
}

src/app/review/dislike.jsx

export const Dislike = props => {
    console.log('dislike')
    return <div>
        <h1>DisLike</h1>
    </div>
}

What if client uses server component but at the same time, i dont want loose server rendering feature?

Yes , You can
  Pass Server Component as prop to child Component

<Client>
	<Server/>
</Client>

steps:
src/app/client/page.js


import MyClient from "./myclient"
import MyServer from "./myserver"

export default function ClientPage() {
    return <div>
        <h1>Client Page</h1>
        {/* <MyClient /> */}
        {/* Pass Server compoent as prop to Child Compoent */}
        <MyClient>
            <MyServer />
        </MyClient>
    </div>
}

src/app/client/myserver.jsx
//server compoent
export default function MyServer() {

    return <div>
        <h1>Server Component</h1>
    </div>
}

src/app/client/myclient.jsx

"use client"
// import MyServer from "./myserver"

export default function MyClient(props) {

    return <div>
        <h1>Client Component</h1>
        {/* <MyServer /> */}
        {props.children}
    </div>
}
............................................................................................
3.Client uses another Client compoent
......................................

Client can uses another client


src/app/likes/page.js
import { MyReview } from "./review"

export default function LikePage() {
    return <div>
        <h1>Like and Dislike Page</h1>
        <MyReview />
    </div>
}

Client Compoenent uses another client called "like.jsx"
src/app/likes/myreview.jsx

'use client'

import { Like } from "./like"

export const MyReview = props => {
    return <>
        <Like></Like>
    </>
}

src/app/likes/like.jsx

'use client'
import { useState } from "react"

export const Like = () => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if client uses another client component, the another component need not use "use client" directive.

src/app/likes/like.jsx


// 'use client'
import { useState } from "react"

export const Like = () => {
    const [like, setLike] = useState(0)
    const onLike = () => {
        console.log('Like')
        setLike(like + 1)
    }
    return <div>
        <h1>Like {like}</h1>
        <button onClick={onLike}>Like</button>
    </div>
}

When this pattern will be very usefull?

You are building web app using next, there would be an use case that you want to use third party ui libs like gridcompoents,tabs.......

By default all third party react components are client components,
......................................&&&&&&&&&&&&&&&&........................................
				Advanced Routing
.....................................................................................

>npx create-next-app@latest
√ What is your project named? ... advanced-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\advanced-routing.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

....................................................................................
				Linking and Navigating
...................................................................................
				Redirection Patterns

1.redirect api:
............
The redirect is the function allows you to redirect the user to another url.

Purpose:
  Redirect uses after a mutation or event
Where:
  Server Components, Server Actions,Route Handlers

Status Code:
 307 - Temp
 303 - Server Actions

Syntax:
export default function update(){
  //update logic
  //update logic is success or failure
  redirect('url') //navigate to the new page
}
Note: this will discuss later when write api handlers and server actions...


2.permanentRedirect:
  It is similar to redirect, but the status would be 308


3.useRouter:
   Client Side Navigation 

4.redirects in next.config.js:
/** @type {import('next').NextConfig} */
const nextConfig = {
    async redirects() {
        return [
            //basic redirection
            {
                source: '/about',
                destination: '/',
                permanent: true
            },
            {
                source: '/myproducts',
                destination: '/products',
                permanent: true
            }
        ]
    }

};

export default nextConfig;

5.NextResponse.redirect:
   Inside Middlewares

.....................................................................................

Client side navigation
 userRouter,Link,History api
Server side navigation
 redirect,PermanentRedirect,routeConfig in next.js,
 Api redirections -NextResponse.redirect



Client Side Navigation:
......................
There are three ways to navigate between routes in Next.js

1.Using <Link> Component
2.Using useRouter hook
3.Using the native history API (browser api)

Note:
  Next js provides lot of in built components

Built in Components:
1.Link
2.Font
3.Image
4.Script

Link:<Link> 

=>Enables fast client-side navigation.
=>It extends the HTML <a> element to provide prefetching and client navigation between routes
=>Link is part of the pacakge called 'next/Link'

Link Props:

1.href - url pattern
2.replace
3.scroll
4.prefetch

Syntax:
 href value can be string or object

<Link href="/customer">Customer</Link>

<Link href={{pathname:'/customer',query: {city:'coimbatore'}}}>Customer</Link>


Note:  

 if you want to share nav bar, site footer across the application, you have to write nav bar inside root layout.

src/app/layout.js
import Link from "next/link";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <h1>My Commerce</h1>
        <hr />
        <nav>
          <Link href={{ pathname: '/customer' }}>Customer</Link> |
          <Link href={{ pathname: '/products' }}>Products</Link>
        </nav>
        {children}
      </body>
    </html>
  );
}

src/app/customer/page.js
export default function CustomerPage() {
    return <>
        <h2>Customer Page</h2>
    </>
}
src/app/customer/layout.js
export default function CustomerLayout({ children }) {
    return <div id="customerlayout">
        {children}
    </div>
}

src/app/product/page.js
export default function ProductPage() {
    return <>
        <h2>Product Page</h2>
    </>
}
...............................................................................
			Code Refactoring

As much as possible we can design ui based on component driven arch,that means spilt the components.

src/app/Footer.jsx

export default function Footer() {
    return <>
        <div>
            <p>Site footer</p>
        </div>
    </>
}
src/app/navbar.jsx
import Link from 'next/link'
export default function NavBar() {
    return <nav>
        <Link href={{ pathname: '/customer' }}>Customer</Link> |
        <Link href={{ pathname: '/products' }}>Products</Link>
    </nav>
}
src/app/Header.jsx

export default function Header() {
    return <>
        <h1>My Commerce</h1>
        <hr />
    </>

}
src/layout.js
import Footer from "./Footer";
import Header from "./Header";
import NavBar from "./navbar";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Header />
        <NavBar />
        {children}
        <Footer />
      </body>
    </html>
  );
}
.....................................................................................
			useRouter Hook
.....................................................................................

useRouter hook allows you programmatically change routes from Client Compoents.
redirect method is used to change routes in Server Components


src/app/dashboard/Nav.jsx

'use client'
import { useRouter } from "next/navigation"

export default function Nav() {
    const router = useRouter()
    return <>
        <div>
            <button onClick={() => {
                router.push('/customer')
            }}>Customer</button>
            <button onClick={() => {
                router.push('/products')
            }}>Product</button>
        </div>

    </>
}
src/app/dashboard/page.js
import Nav from './Nav'
export default function Dashboard() {
    return <>
        <h1>Dashboard</h1>
        <Nav />
    </>
}

src/app/navbar.jsx
import Link from 'next/link'
export default function NavBar() {
    return <nav>
        <Link href={{ pathname: '/customer' }}>Customer</Link> |
        <Link href={{ pathname: '/products' }}>Products</Link> |
        <Link href={{ pathname: '/dashboard' }}>Dashboard</Link>
    </nav>
}
....................................................................................
			  Browser history api
....................................................................................

We can use browser's history api.

window.history.pushState  === router.push

Since we are using next router apis, we dont need to use raw browser apis

Note: Recommended is to use Next router apis
.....................................................................................
			Advanced Routing - Dynamic Routes
.....................................................................................

>npx create-next-app@latest
√ What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\dynamic-routes.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss


What is dynamic route?
	When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.


Convention:
  A Dynamic Segment can be created by wrapping a folder's name in square brackets:    [folderName].
   For example, [id] or [slug].

  Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions..

Use case:
 if you want to build master detail Page.

Master
src/app/profiles/page.js

Details
src/app/profiles/[id]/page.js
                  |
               place holder


URL Pattern:

http://localhost:3000/profiles/1

src/app/
      profiles
	|
        page.js
        layout.js
      [id]
         page.js
         layout.js

src/app/profiles/page.js

export default function Home() {
    return <h1>
        Profile Page
    </h1>
}

src/app/profiles/[id]/page.js

export default function ProfileDetailsPage() {
    return <div>
        <h1>Profile Details</h1>
    </div>
}

How to access Path parameters inside  Details Page?

via props

props.params =>{"id":"2"}

eg:

// export default function ProfileDetailsPage(props) {
//     return <div>
//         {/* <h1>Profile Details {JSON.stringify(props)}</h1> */}
//         <h1>{props.params.id} details</h1>
//     </div>
// }

export default function ProfileDetailsPage({ params: { id } }) {
    return <div>
        {/* <h1>Profile Details {JSON.stringify(props)}</h1> */}
        <h1>{id} details</h1>
    </div>
}
.....................................................................................
		    Master Details Page Preparation using Mock Data
.....................................................................................

Steps:

1.Have some mock data
 src/app/mock-data/todos.js - Refer code

2.Have Master page
 src/app/todos/page.js
import Link from "next/link";
import { TODOS } from "../mock-data/todos";

export default function TodosMasterPage() {
    return <>
        <h1>Todos Master Page</h1>
        {/* Prepare dynamic menu */}
        <ul>
            {
                TODOS.map(todo => {
                    return <li>
                        <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}
3.Have details Page
 src/app/todos/[id]/page.js
export default function TodosDetailsPage({ params: { id } }) {
    return <div>
        <h1>{id} details</h1>
    </div>
}
.....................................................................................
		    Master Details Page Preparation using API calls
.....................................................................................

In Next js api calls are made using "fetch" api by default.
fetch is promised powered , when ever or where you call fetch api , you can use async await keywords.

server component functions, apis can be marked as async keyword.

eg
src/app/posts/page.js ->Master page.

import Link from "next/link";

export async function fetchPosts() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts')
    const posts = await response.json()
    //here we return promise
    return posts;
}

export default async function PostsPage() {
    const posts = await fetchPosts()
    return <>
        <h1>Posts Master Page</h1>
        {/* Prepare dynamic menu */}
        <ul>
            {
                posts.map(post => {
                    return <li>
                        <Link href={`/posts/${post.id}`}>{post.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/posts/[id]/page.js
export default function PostsDetailsPage({ params: { id } }) {
    return <div>
        <h1>{id} details</h1>
    </div>
}

Assignment:
 Make an api call in  the details to fetch particular post and fill it.
....................................................................................
		        Advanced Routing-Dynamic Routes
			   Catch-all Segment Routing
...................................................................................

Dyamic segments can be extended to catch all subsequent segements by adding [...slug]

eg:

without catchall

  shop
   |
   [a]
    |
     page.js  /shop/a
   |
   [b]
     |
     page.js /shop/a/b
    |
    [c]
     |
      page.js  /shop/a/c



with catch all
 shop
  |
   page.js
  
  [...slug]
     |
   page.js

Eg:
 /shop/tops
 /show/tops/tshirt
 /show/dress/men/shirt
  
How to capture paramers
 {
   slug: ['tops','tshirt','men,'shirt']
 }

EG:
 src/app/shop/page.js

export default function ShopPage() {
    return <>
        <h1>Shop Page</h1>
    </>
}
src/app/shop/[...slug]/page.js

export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page {JSON.stringify(params)}</h1>
    </>
}
Url Pattern:
http://localhost:3000/shop/cloths/tops/t-shirts

Response:
Shop Details Page {"slug":["cloths","tops","t-shirts"]}

....................................................................................
		        Advanced Routing-Dynamic Routes
		        Optional Catch-all Segment Routing
...................................................................................

shop
  |
   page.js
  
  [...slug]
     |
   page.js

let us assume that, if you want to show shop, /shop we need page.js inside shop folder.

With Optional Catch all:
........................

shop
  |
  [[...slug]]
     |
   page.js

eg:

src/app/shop/[[...slug]]/page.js

export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page {JSON.stringify(params)}</h1>
    </>
}

Testing:
http://localhost:3000/shop
Response
Shop Details Page {}

http://localhost:3000/shop/cloths/tops
Response
Shop Details Page {"slug":["cloths","tops"]}
....................................................................................
		        Advanced Routing- Parallel Routes		     
...................................................................................

What is Parallel Route?

Generally inside a layout, we render only one page by default.

What if i want to render "Mutiple Pages" inside single layout simultaneously or conditionally.

"Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.For highly dynamic sections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns"


Single Page within layout : Component View:
...........................................
<Layout>
     <Page/>
</Layout>

Multiple pages within Single Layout: Component View

<Layout>
  <PageOne/>
  <PageTwo/>
</Layout>

What if i want to render page conditionally? Conditional Rendering

<Layout>
    {condition ? <ThisPage/> : <ThatPage/>}
</Layout>

Basic Structure:

 src/app
     |
     layout.js -root layout
     page.js  -root page
   |
   info
     |
     layout.js -info layout
     page.js  - info page

Here, only info page is inserted into info layout
now I want to display two pages called team and analytics within info layout.

npx create-next-app@latest
√ What is your project named? ... parallel-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\parallel-routing.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

Steps:

1.src/app/game/layout.js
export default function GameLayout(props) {
    return <div id="gamelayout">
        {props.children}
    </div>
}
2.src/app/game/page.js

export default function GamePage() {
    return <div>
        <h1>Game Page</h1>
    </div>
}

3.Parralel Routing, we need to create folder with following syntax

@FolderName
   |
  page.js
  layout.js

src/app/game/@team/page.js
export default function TeamPage() {
    return <div>
        <h1>Team Page</h1>
    </div>
}
Now if you test
http://localhost:3000/game/team
 The output would be page not found, the reason is you cant access team page publicily
team page must be injected into "Games layout as prop".

src/app/game/@anaylitics/page.js
export default function AnalyticsPage() {
    return <div>
        <h1>Analytics Page</h1>
    </div>
}


4.Insert Team and anayltics page content into game layout.

src/app/game/layout.js
export default function GameLayout(props) {
    return <div id="gamelayout">
        {/* Game Page Content */}
        {props.children}
        {/* Team Page Content */}
        {props.team}
        {/* Anaylytics Page Content */}
        {props.anaylitics}
    </div>
}
...................................................................................
		Parallel Routing - Conditional Rendering
...................................................................................

As of now we have seen how to render multiple pages into a layout.
Now we are going to discuss how to render page or pages into a layout based on condition.

Slots:
  Portion of UI
  Slots are defined using named slots.
  Slots are defined with @folder convention.
  For eg @team,@player
  Slots are passed as props to the shared parent layout.

We render a slot based UI based on certain conditions, such as checkbox and options, authentication states.

Syntax:

@AdminPanel
@UserPanel

export default function MyLayout(props){
   const isAdmin = getUser()
   return isAdmin ? props.AdminPanel : props.UserPanel
}

src/app/panel/page.js

export default function PanelPage() {
    return <div>
        <h1>Panel Page</h1>
    </div>
}


src/app/panel/layout.js
export default function PanelLayout(props) {
    return <div id="PanelLayout">

    </div>
}

src/app/panel/@AdminPanel/page.js
export default function AdminPanelPage() {
    return <div>
        <h1>Admin Panel Page</h1>
    </div>
}
src/app/panel/@UserPanel/page.js
export default function UserPanelPage() {
    return <div>
        <h1>User Panel Page</h1>
    </div>
}

src/app/panel/layout.js
export default function PanelLayout(props) {
    const isAdmin = false
    return <div id="PanelLayout">
        {/* Panel Page content */}
        {props.children}
        {isAdmin ? props.AdminPanel : props.UserPanel}
    </div>
}
....................................................................................
			ParrelRouting -UnMatched Routing
...................................................................................

default.js
 You can define default.js file to render as a fallback for unmatched slots during the inital load or full page reload.

src/app/panel/@UserPanel/default.js

export default function DefaultPage(props) {
    return <div>
        <h1>Fallback Page</h1>
    </div>
}
....................................................................................
			Advanced Routing-Route Groups
....................................................................................

When ever you create folder under app dir which is exposed as a route.
src/app/user/  ====> /user

However, you can mark a folder as a "Route Group"  to prevent the folder from being included in the route's URL Path. 

Which is sometimes called hidden dirs

Why Route Groups:
 =>Organize your route segments and project files into logical groups without affecting the URL Path structure.
 =>Organizing routes into groups eg: site section,intent, or team.
 =>Enabling nested layouts in the same route segment level.
    =>You can have mutliple nested layouts in the same segment, including multiple         root  layouts
 
Convention:
  A route group can be created by wrapping a folder's name in parenthesis
  (folderName)

Basic Route Group:
..................
npx create-next-app@latest
√ What is your project named? ... route-groups
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\route-groups.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

src/app/(auth)
 -login
   page.js
 -signup
   page.js


src/app/(auth)/login/page.js

export default function LoginPage() {
    return <div>
        <h1>Login Page</h1>
    </div>
}

src/app/(auth)/signup/page.js

export default function SignUpPage() {
    return <div>
        <h1>Signup Page</h1>
    </div>
}
Testing:
http://localhost:3000/signup
http://localhost:3000/login

This will throw error, because auth is hidden
http://localhost:3000/auth/login 
....................................................................................
			Advanced Routing-Route Groups
			   (Shared Layout)
....................................................................................
How to share common layout for all modules/domains/groups?

src/app/layout.js

How to share layout for a domain like auth,marketing,products?

src/app/(auth)/layout.js
export default function AuthLayout({ children }) {
    return <div id="authLayout">
        {children}
    </div>
}
....................................................................................
			 Advanced Routing-Route Groups
			   (Spefic  Layout for a route)
....................................................................................
How to have specific layout for a route?

src/app/(auth)/login/layout.js
export default function LoginLayout({ children }) {
    return <div id="loginlayout">
        {children}
    </div>
}
....................................................................................
			     Advanced Routing-Route Groups
			   (Creating Multiple Root Layouts )
....................................................................................
if you need mutltiple root layouts, for eg i am building ecommerce app, where auth is separate domain, products separate domain.

YOu can have layout.js inside each domain. we have to remove root layout file.
Inside domain layout, you have to return html  

Steps:
1.just remove src/app/layout.js or rename.

2.add src/app(auth)/layout.js


export default function AuthRootLayout({ children }) {
    return (
        <html lang="en">
            <body>
                <div id="authRootLayout">
                    {children}
                </div>
            </body>
        </html>
    );
}
....................................................................................
			Advanced Routing-Route Intercepting
....................................................................................

What is intercepting route?

 Incercepting routes allows you to load a route from another part of your application within the current layout.
 This routing paradigm can be usefull when you want to display the content of a route without the user switching to a different context.

For example, when clicking on a photo from within a feed, a modal overlaying the feed should show up with the photo. In this case, Next.js intercepts the /feed route and "masks" this URL to show /photo/123 instead.

However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.

Convention:
   Intercepting routes can be defined with (..) convention, which is similar to relative path convention ../ but for segments

Syntax:
 (.) - to match segments on the same level
 (..) -to match segments on one level above
 (..)(..)- to match segments on two levels above
 (...) - to match segments from the root app dir

eg:
(.)photos

Code:
We are going to create photo gallary app.

1. When navigating within the application, it is rendered as a modal
2. When the page is refreshed, it is rendered as a standalone page

1.Model dialog code
2.Route Interceptor

npx create-next-app@latest
√ What is your project named? ... route-interceptor
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\route-interceptor.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

src/app/mock-data/photo.js
const photos = [
    {
        id: '1',
        name: 'Kevin Canlas',
        href: 'https://twitter.com/kvncnls/status/1471832344986324998',
        username: '@kvncnls',
        imageSrc: 'https://pbs.twimg.com/media/FGz_t1wXIAIFyT-?format=jpg',
    },
    {
        id: '2',
        name: 'Pedro Duarte',
        href: 'https://twitter.com/peduarte/status/1463897468383412231',
        username: '@peduarte',
        imageSrc: 'https://pbs.twimg.com/media/FFDOtLkWYAsWjTM?format=jpg',
    },
    {
        id: '3',
        name: 'Ahmad Awais',
        href: 'https://twitter.com/MrAhmadAwais/status/1338151679083032577',
        username: '@MrAhmadAwais',
        imageSrc: 'https://pbs.twimg.com/media/EpIR281XIAMUrEM?format=jpg',
    },
    {
        id: '4',
        name: 'Leandro Soengas',
        href: 'https://twitter.com/lsoengas/status/1352302741339693061',
        username: '@lsoengas',
        imageSrc: 'https://pbs.twimg.com/media/EsRYK8oWMAEkObV?format=jpg',
    },
    {
        id: '5',
        name: 'Samina',
        href: 'https://twitter.com/saminacodes/status/1466479548837482497',
        username: '@saminacodes',
        imageSrc: 'https://pbs.twimg.com/media/FFn7X76VgAEVTgs?format=jpg',
    },
    {
        id: '6',
        name: 'lafond.eth',
        href: 'https://twitter.com/laf0nd/status/1464640065615929346',
        username: '@laf0nd',
        imageSrc: 'https://pbs.twimg.com/media/FFNyYEAXsAMdOhV?format=jpg',
    },
    {
        id: '7',
        name: '山岸和利💛',
        href: 'https://twitter.com/ykzts/status/1426358452356407297',
        username: '@ykzts',
        imageSrc: 'https://pbs.twimg.com/media/E8txb2yVkAQxRVw?format=jpg',
    },
    {
        id: '8',
        name: 'Altngelo',
        href: 'https://twitter.com/AfterDarkAngelo/status/1456372859090075648',
        username: '@AfterDarkAngelo',
        imageSrc: 'https://pbs.twimg.com/media/FDYTZN1VIAAT-X1?format=jpg',
    },
    {
        id: '9',
        name: 'Matias Baldanza',
        href: 'https://twitter.com/matiasbaldanza/status/1404834163203715073',
        username: '@matiasbaldanza',
        imageSrc: 'https://pbs.twimg.com/media/E374pyaWEAMCT2R?format=jpg',
    },
];

export default photos;

src/app/page.js

import photos from "./mock-data/photo"
import Link from 'next/link'
import Image from 'next/image'

export default function Home() {

  return <main className="container mx-auto">
    <h1 className="text-center text-4xl font-bold m-10">Photo Gallery App</h1>
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 auto-rows-max	 gap-6 m-10">
      {/* show photos */}
      {photos.map(({ id, imageSrc }) => (
        <Link key={id} href={`/photos/${id}`}>
          <Image
            alt=""
            src={imageSrc}
            height={500}
            width={500}
            className="w-full object-cover aspect-square"
          />
        </Link>
      ))}
    </div>
  </main>
}

in order to show images which is accessed from outside domain, we need to configure the next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        domains: ['pbs.twimg.com'],
    },
};

export default nextConfig;

Master detail Page:
...................

src/app/photos/[id]/page.js

import photos from "@/app/mock-data/photo";
import Image from 'next/image'

export default function PhotoPage({ params: { id } }) {
    const photo = photos.find(p => p.id === id)
    return <div className="container mx-auto my-10">
        <div className="w-1/2 mx-auto border border-gray-700">
            {/* <Image
                alt=""
                src={photo.imageSrc}
                height={500}
                width={500}
                className="w-full object-cover aspect-square"
            /> */}
        </div>
    </div>
}

Instead of display image inside same component,we can create separte Framework component

src/app/components/Frame.jsx
import Image from 'next/image'
export default function Frame({ photo }) {
    return (
        <>
            <Image
                alt=""
                src={photo.imageSrc}
                height={600}
                width={600}
                className="w-full object-cover aspect-square col-span-2"
            />

            <div className="bg-white p-4 px-6">
                <h3>{photo.name}</h3>
                <p>Taken by {photo.username}</p>
            </div>
        </>
    )
}

Pass image as prop to The Frame Compoent.
src/app/page.js
import Frame from "@/app/components/Frame";
import photos from "@/app/mock-data/photo";
import Image from 'next/image'

export default function PhotoPage({ params: { id } }) {
    const photo = photos.find(p => p.id === id)
    return <div className="container mx-auto my-10">
        <div className="w-1/2 mx-auto border border-gray-700">
            {/* <Image
                alt=""
                src={photo.imageSrc}
                height={500}
                width={500}
                className="w-full object-cover aspect-square"
            /> */}
            <Frame photo={photo} />
        </div>
    </div>
}

Modal Diaglog:

src/app/components/Model.jsx
'use client'
import { useRef, useCallback, useEffect } from "react"
import { useRouter } from "next/navigation"

export default function Modal({ children }) {
    const overlay = useRef(null)
    const wrapper = useRef(null)
    const router = useRouter()
    //hooks for controlling client navigation
    const onDismiss = useCallback(() => {
        router.back()
    }, [router])

    const onClick = useCallback(
        (e) => {
            if (e.target === overlay.current || e.target === wrapper.current) {
                if (onDismiss) onDismiss()
            }
        },
        [onDismiss, overlay, wrapper]
    )
    const onKeyDown = useCallback(
        (e) => {
            if (e.key === 'Escape') onDismiss()
        },
        [onDismiss]
    )

    //useEffect  === ComponentDidUpdate
    useEffect(() => {
        document.addEventListener('keydown', onKeyDown)
        return () => document.removeEventListener('keydown', onKeyDown)
    }, [onKeyDown])
    return (
        <div
            ref={overlay}
            className="fixed z-10 left-0 right-0 top-0 bottom-0 mx-auto bg-black/60"
            onClick={onClick}
        >
            {/* This div will show the photo */}
            <div
                ref={wrapper}
                className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full sm:w-10/12 md:w-8/12 lg:w-1/2 p-6"
            >
                {children}
            </div>
        </div>
    )

}

Create Parallel Route to display Modal:
.........................................

create default.js 

src/app/@modal/default.js

export default function Default() {
    return null
}

Note: In the Intercepting routing, parrel route must have default.js which should return null.


src/app/@modal/(.)photos/[id]/page.js
import photos from "@/app/mock-data/photo"
import Frame from "@/app/components/Frame"

export default function PhotoModal({ params: { id: photoId } }) {
    const photo = photos.find((p) => p.id === photoId)

    return (
        <Modal>
            <Frame photo={photo} />
        </Modal>
    )
}
....................................................................................
			 Styling - CSS,IMAGES,Fonts
.....................................................................................

Types of styling:

1.Global Css
2.CSS Modules
3.CSS Frameworks
  ->Tailwind
  ->Bootstrap
  -SASS
4.CSS in js

Global css:

Next provides file called global.css where you can add global css and also sass directives.
src/app/global.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

How to use css inside page or layout?

import statement and className attribute



import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

Image:
 Image is component which must be used instead html img element.

	<Image
                alt=""
                src={photo.imageSrc}
                height={500}
                width={500}
                className="w-full object-cover aspect-square"
            /> 


Fonts:
 Next provides fonts module which integrates google fonts which would be part of 
the package 'next/font/google'
 
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });


export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

CSS Modules:

src/app/dashboard/dashboard.module.css
.dashboard {
    padding: 24px;
    border: 10px;
    text-align: center;
    border-color: blue;
    background-color: aquamarine;
}

src/app/dashboard/layout.js
import styles from './dashboard.module.css'

export default function DashboardLayout(props) {
    return <div className={styles.dashboard}>
        {props.children}
    </div>
}
....................................................................................
			      Data Fetching
....................................................................................

Data fetching is nothing but talking to apis particulary REST API OR GraphQL 
Next app can fetch data either from external end points or internal end points, next provides a feature to build rest apis.

Page can talk directly to External api 
Next Page---------------------->External API 

Page can talk to NEXT API which intern calls External API 
Next Page-------------|NEXT API-------->External API 

Page can talk to NEXT API Which talks to databases 
Next Page-------------|NEXT API-------->Databases 

Types of Data fetching:
.......................

1.Server side data fetching
2.Client side data fetching

Server side data fetching:

=>Whenever possible, we recommend fetching data on the server. This allows you to:

=>Have direct access to backend data resources (e.g. databases).

=>Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.

=>Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.

=>Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.

=>Reduce client-server waterfalls.

=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

Fetching Data Where It's Needed:

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.

 Parent - Layout  - apicallurl eg fetch('/api/customers')
   |
   child  - Layout -apicallsameurl -fetch('/api/customers')
     |
     child -Layout -apicallsameurl -fetch('/api/customers')
       |
      child -Layout -apicallsameurl -fetch('/api/customers')
        |
        child- Page -apicallsameurl -fetch('/api/customers')

.....................................................................................
		  Server side data fetching using "fetch" api
.....................................................................................

Fetching data on the server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.
React extends fetch to automatically memoize fetch requests while rendering a React component tree.


There are four places You can use fetch:
1.Server components
2.Client Components
3.Route Handlers,REST API
4.Server Actions

You can use fetch with async/await in "Server Components", in "Route Handlers", and in "Server Actions".

Eg: 
Fetch api In server components


npx create-next-app@latest
√ What is your project named? ... data-fetching
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\data-fetching.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss

fetch with external api:
........................

src/app/todos/page.js


//write a function to fetch data 
export async function fetchTodos() {
    const url = 'https://jsonplaceholder.typicode.com/todos'
    const response = await fetch(url);
    return response.json()
}

export default async function TodosPage() {
    const todos = await fetchTodos();

    return <>
        <h1>Todos Page</h1>
        <ul>
            {
                todos.map(todo => {
                    return <li>{todo.title}</li>
                })
            }
        </ul>
    </>
}

.....................................................................................
		  Server side data fetching using  "third party" api-axios
.....................................................................................

You can use any third party ajax api to call apis from next application but which is not recommended, because other apis will not have features such as caching,revalidation,request memoziation, we have to write extra code.
.....................................................................................
	     Data fetching in Client components-Using fetch api
....................................................................................

'use client'

import { useEffect, useState } from "react";

const FetchPost = () => {
    const [posts, setPosts] = useState([])
    useEffect(() => {
        async function fetchPostsDetails() {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const response = await fetch(url);
            const posts = await response.json()
            console.log(posts)
            setPosts((myposts) => {
                return posts.concat(myposts)
            })
        }
        fetchPostsDetails()
        return () => {
            return null;

        }
    }, [])
    return <>
        <h1>Posts</h1>
        <ul>
            {
                posts.map(post => {
                    return <li>{post.title}</li>
                })
            }
        </ul>
    </>
}
export default FetchPost;


Using fetch api in client components is not recommened, the reason which has no any caching fetching in client side is not enabled,
.....................................................................................
	     Data fetching in Client components-Using SWR api
....................................................................................
What is SWR?
  The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861(opens in a new tab).
 SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.

 SWR is wrapper for fetch api only.

Why SWR
1.Client side caching by default
2.Cache revalidation by default
3.You dont need to write hooks like useEffect,useState,
4.You get data,error,loading flags

npm install swr

src/app/posts/compoents/PostClientUsingSWR.jsx

'use client'
import useSWR from "swr"

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}

function FetchPostsUsingSWR() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div>
            <h1>Failed to return</h1>
        </div>
    }
    if (isLoading) {
        return <h1>Loading...</h1>
    }
    return <ul>
        {
            data.map(post => {
                return <h2>{post.title}</h2>
            })
        }
    </ul>
}

export default FetchPostsUsingSWR;

src/app/posts/page.js
import FetchPost from "./components/PostClient"
import FetchPostsUsingSWR from "./components/PostClientUsingSWR"

export default function PostPage() {
    return <div>
        <h1>Post Page</h1>
        {/* Using fetch api */}
        {/* <FetchPost /> */}
        <FetchPostsUsingSWR />
    </div>
}
.....................................................................................
			Data Fetching using Route Handler
		      (REST API Development and Integration)
.....................................................................................

Next.js provides a layouter called "API" layer in order to build REST API.

API layer can be used to write REST API Which may talk to databases or external rest apis or GraphQL api or Microservices...

Route Handler:
  Route handlers are used to create REST API in next.js

Convention:
 route.js

src/app/todos/
        page.js
        layout.js
        route.js --- this folder is not recommended

src/app/api/
        todos
	 -route.js
        customers
         -route.js
        products
         -route.js
	 |
         [id]
          |
          route.js
url pattern:
  /api/todos
  /api/products/1
  
npx create-next-app@latest
√ What is your project named? ... restapi-routers
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\restapi-routers.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom

.....................................................................................

Inside route handlers we write rest apis:

syntax:

export async function HTTPVERB(request){

}

=>Always route function must have "export" only.
=>Function must have async keyword
=>Function args must have request object.

Supported HTTP VERBS:
  GET
  POST
  PUT
  PATCH
  DELETE
  HEAD
  OPTIONS

APIS:
 NextRequest object used to handle client request
 NextResponse Object used to send respons to the client.

=>Function name must be HTTP Verb name like "GET"

// routers 

src/app/api/greeter/route.js
import { NextResponse } from "next/server";

export async function GET(request) {
    //return response
    return NextResponse.json({ message: 'hello' })
}
....................................................................................
			How to read Request Parameter
...................................................................................

Dynamic parameters:

URL:
http://localhost:3000/api/greeter/welcome

src/app/api/greeter/[message]/route.js
// routers 

import { NextResponse } from "next/server";

export async function GET(request, { params }) {
    console.log(params)
    //return response
    return NextResponse.json({ message: params.message })
}
.....................................................................................
		 How to read payload -body -Post Request
.....................................................................................
// routers 

src/app/api/greeter/route.js

import { NextResponse } from "next/server";

export async function GET(request) {
    //return response
    return NextResponse.json({ message: 'hello' })
}
//post 
export async function POST(request, { params }) {
    //read body 
    const payload = await request.json()
    console.log(payload)
    return NextResponse.json({ message: 'saved' })
}
.....................................................................................
Recommendations:
................
findAll
Save Operations
 
write inside
  src/app/api/customers/route.js

findById
deleteById
updateById
 Any api which has parameters
 write inside

 src/app/api/customers/[id]/route.js
.....................................................................................	

CURD operations:

1.You can talk to external API
2.You can talk to databases

External API Integration:
.........................

Next UserInterface(pages,layouts)--------->API Layer----------->External API



src/app/api/alubums/route.js
import { NextResponse } from "next/server"

const url = 'https://jsonplaceholder.typicode.com/albums'

//GET ALL albums
export async function GET(request) {
    const response = await fetch(url)
    const albums = await response.json()
    return NextResponse.json(albums)
}

//POST 
export async function POST(request) {

    const album = await request.json()
    const res = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(album)
    })
    const newAlbum = await res.json()
    return NextResponse.json(newAlbum)
}

//GET BY ID,UPDATE BY ID,DELETE BY ID:
......................................
src/app/api/albums/[id]/route.js

import { NextResponse } from "next/server";

const url = `https://jsonplaceholder.typicode.com/albums`


//GET ALBUM BY id
export async function GET(request, { params }) {
    const id = params.id
    const response = await fetch(`${url}/${id}`)
    const album = await response.json()
    return NextResponse.json(album)
}

//UPDATE Album by id 
export async function PUT(request, { params }) {
    //const album = await request.json()
    const { title } = await request.json()
    const id = params.id
    const res = await fetch(`${url}/${id}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ title })
    })
    const updatedAlbum = await res.json()
    return NextResponse.json(updatedAlbum)
}

//DELETE Albumb by id :
export async function DELETE(request, { params }) {
    const id = params.id
    const res = await fetch(`${url}/${id}`, {
        method: 'DELETE'
    })
    const deletedAlbum = await res.json()
    return NextResponse.json(deletedAlbum)
}
.....................................................................................
		    	   Externalization
.....................................................................................

In the above example we have hard coded urls. What if i dont want to hard code

const url = `https://jsonplaceholder.typicode.com/albums`

How to externalize the data like urls?

We have file called ".env" file.

Enviroment Variables:
.....................

Next js comes with built in support for env variables which allows you to make  your app more configurable, more flexiable.

File Syntax
.env 
.env.enviroment
 envirronment would be "dev or prod or test"

.env.development
.env.production
.env.test
.env.local

projectName/.env 
eg:
restapi-routers/.env

ALBUMS_URL="https://jsonplaceholder.typicode.com"


src/app/api/albums/route.js
import { NextResponse } from "next/server"

//const url = 'https://jsonplaceholder.typicode.com/albums'
const url = `${process.env.ALBUMS_URL}/albums`

//GET ALL albums
export async function GET(request) {
    const response = await fetch(url)
    const albums = await response.json()
    return NextResponse.json(albums)
}

//POST 
export async function POST(request) {

    const album = await request.json()
    const res = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(album)
    })
    const newAlbum = await res.json()
    return NextResponse.json(newAlbum)
}
.....................................................................................
                     Data Fetching using Routers
/////////////////////////////////////////////////////////////////////////////////////


src/app/albums/page.js

export async function fetchAlbums() {
    //const url = 'https://jsonplaceholder.typicode.com/todos'
    const url = `${process.env.HOST}/albums`
    const response = await fetch(url);
    return response.json()
}
export default async function AlbumsPage() {
    const albums = await fetchAlbums();

    return <>
        <h1>Albums Page</h1>
        <ul>
            {
                albums.map(album => {
                    return <li>{album.title}</li>
                })
            }
        </ul>
    </>
}

Task:
 You have to build master detail page
...................................................................................
			  Database Integration
...................................................................................

Next js can integrate with any database including sql(mysql,oracle,postgresql) and no sql (mongo,neodb,redis)

In order to talk to databases application uses database drivers and apis.

Mostly we use using database frameworks called "ORM"-Object Relational Mapping framework.

For Node.js, we have many frameworks

1.Prisma
2.Sequelize
3.Type ORM
etc....

We are going to use "Prisma".

Steps:
1.create  a project
>npx create-next-app@latest
√ What is your project named? ... db-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\db-app.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom
- next

2.install prisma framework.

Before installing prisma framework, we have to decide what database we are going to use.

If you are going to use Postgres sql database,then Postgressql database must have been installed.

How to install database? What ever database?

1.Download database like postgres 
2.install locally.

In modern days, we never download database and install, then how to download and install.
via container technologies like "Docker"

Now, i am going to use "inmemory" database, we dont even need docker.

Note: In memory databases not for production, or not for real time applications.
only for learning purpose.

InMemory databses:
1.sqlite
2.H2
etc....

we are going to use "sqlite" database.


install prisma with sqlite integration.


E:\session\TADigital\db-app>npx prisma init --datasource-provider sqlite
Need to install the following packages:
prisma@5.8.1
Ok to proceed? (y) y

✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run npx prisma db pull to turn your database schema into a Prisma schema.
3. Run npx prisma generate to generate the Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
.....................................................................................
			   ORM Fundamentals
.....................................................................................

Object  Relational    Mapping
 |        |            |
Enity   RDBMS         Binding

In Database Program, we use sql quries for creating,inserting,updating,deleting

In ORM world, SQL Queries are abstracted by apis like save,findAll,findById,remove,update.

Entity represents "table" in the database.
 
schema:
   The plan or structure.

Define Model(Enity)

model User{

}
model Product {

}
....

Fields:
  Fields are mapped in the table as columns

model Comment {
  id Int @id @default(autoincrement())
  title String
  content String
}

Where to define this model?

prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

//Define Model- Map tables against database
model User {
  id        String   @id @default(uuid())
  name      String
  email     String
  role      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
....................................................................................
			Map Model in the database
....................................................................................

E:\session\TADigital\db-app>npx prisma migrate dev --name init
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

Applying migration `20240130045105_init`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20240130045105_init/
    └─ migration.sql

Your database is now in sync with your schema.

Running generate... (Use --skip-generate to skip the generators)

added 6 packages, and audited 27 packages in 8s

3 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

added 1 package, and audited 28 packages in 4s

3 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

✔ Generated Prisma Client (v5.8.1) to .\node_modules\@prisma\client in 62ms


After running, you will able to see the table structure.

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);
...................................................................................
			Seeding database
...................................................................................

This step is only for testing, which is optional in production apps.

While app starts if you want to insert some data, for testing, you can seed database.

prisma/seed.mjs
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient()

async function main() {
    const user = await prisma.user.create({
        data: {
            name: 'admin',
            email: 'admin@gmail.com',
            role: 'admin'
        },
    })
    console.log('created', user)
}
main().then(() => prisma.$disconnect()).catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit()
})

packag.json.
{
  "name": "db-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "prisma": {
    "seed": "node prisma/seed.mjs"
  },
  "dependencies": {
    "@prisma/client": "^5.8.1",
    "next": "14.1.0",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "prisma": "^5.8.1"
  }
}

Seeding:
.......

E:\session\TADigital\db-app>npx prisma db  seed
Environment variables loaded from .env
Running seed command `node prisma/seed.mjs` ...
created {
  id: 1,
  name: 'admin',
  email: 'admin@gmail.com',
  role: 'admin',
  createdAt: 2024-01-30T05:14:59.223Z,
  updatedAt: 2024-01-30T05:14:59.223Z
}

The seed command has been executed.
...................................................................................
			 Client api

Client api will help to talk to database from rest api.

src/lib/prisma.js
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global;

export const prisma = globalForPrisma.prisma || new PrismaClient({
    log: ["query"]
})

....................................................................................
			 Rest api with Prisma
..................................................................................

src/app/api/users/route.js
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";


//read all users
export async function GET() {
    const users = await prisma.user.findMany({})
    if (!users) {
        return NextResponse.json({ message: 'No Users Found', code: 404 })
    } else {
        return NextResponse.json(users)
    }
}
//create new User 
export async function POST(request) {
    try {
        const json = await request.json()
        const user = await prisma.user.create({
            data: json
        })
        return new NextResponse(JSON.stringify(user), {
            status: 201, headers: {
                "Content-Type": "application/json"
            }
        })
    }
    catch (err) {
        if (error.code === "P2002") {
            return new NextResponse("User with email already Exist", { statuscode: 409 })
        }
        return new NextResponse(err.message, { statuscode: 500 })
    }
}
..............
GETBYID,update,delete

src/app/api/user/[id]/route.js

import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";


//Get User by id
export async function GET(request, { params }) {
    const id = Number(params.id)

    const user = await prisma.user.findUnique({
        where: {
            id
        }
    })
    if (!user) {
        return NextResponse.json({ message: `No User Found with ID ${id}`, code: 404 })
    } else {
        return NextResponse.json(user)
    }
}

export async function PATCH(request, { params }) {
    try {
        const id = Number(params.id)
        const user = await request.json()
        const updatedUser = await prisma.user.update({
            where: { id },
            data: user
        })
        if (!updatedUser) {
            return NextResponse.json({ message: `No User Found with ID ${id}`, code: 404 })
        }
        return NextResponse.json(updatedUser)

    } catch (err) {
        if (error.code === "P2002") {
            return new NextResponse("User with ID already Exist", { statuscode: 409 })
        }
        return new NextResponse(err.message, { statuscode: 500 })
    }
}

//delete 
export async function DELETE(request, { params }) {
    try {
        const id = Number(params.id)
        if (!id) {
            return NextResponse.json({ message: `No User Found with ID ${id}`, code: 404 })
        } else {
            await prisma.user.delete({
                where: {
                    id
                }

            })
            return new NextResponse(null, { status: 204 })
        }


    }
    catch (err) {
        return new NextResponse(err.message, { statuscode: 500 })
    }
}
.....................................................................................
				SSG-Static Site Generation
.....................................................................................

Rendering pages happen during build time.

The generateStaticParams function can be used in combination with dynamic route segments to define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time.

npx create-next-app@latest
√ What is your project named? ... ssg-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\ssg-app.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom
- next

How to build ssg apps?

=>You have to over ride the function called "generateStaticParams" 
=>generateStaticParams function gets called only during build time...

Step 1:
 Create Master Page.

src/app/todos/page.js
//Master page

import Link from "next/link";

export async function fetchTodos() {
    const url = 'https://jsonplaceholder.typicode.com/todos'
    const response = await fetch(url)
    return response.json()
}

export default async function TodosPage() {
    const todos = await fetchTodos();
    return <div>
        <ul>
            {
                todos.map(todo => {
                    return <>
                        <li>
                            <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                        </li>
                    </>
                })
            }
        </ul>
    </div>
}

Create Details Page.

Override generateStaticParams methods

export async function fetchTodos() {
    const url = 'https://jsonplaceholder.typicode.com/todos'
    const response = await fetch(url)
    return response.json()
}

export default function TodosDetailsPage(props) {
    return <div>
        <h1> {props.params.id} - Todos Details Page</h1>
    </div>
}

//generateStaticParams method 

export async function generateStaticParams() {
    //this method must return array
    console.log('building')
    const todos = await fetchTodos()
    //generate html pages for all todos:if you have 100 records, 100 html file would be generated
    return todos.map(todo => {
        //based on id only the pages are generated,id value must be string
        let id = todo.id.toString()
        return {
            id: id
        }
    })
}

In order to test this code , we need to build and we need to run application using prod mode.

npm run build
E:\session\TADigital\ssg-app>npm run build

> ssg-app@0.1.0 build
> next build

   ▲ Next.js 14.1.0

   Creating an optimized production build ...
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
   Collecting page data  ...building
 ✓ Collecting page data
 ✓ Generating static pages (206/206)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    143 B          84.3 kB
├ ○ /_not-found                          885 B            85 kB
├ ○ /todos                               6.94 kB        91.1 kB
└ ● /todos/[id]                          143 B          84.3 kB
    ├ /todos/1
    ├ /todos/2
    ├ /todos/3
    └ [+197 more paths]
+ First Load JS shared by all            84.1 kB
  ├ chunks/69-1b6d135f94ac0e36.js        28.9 kB
  ├ chunks/fd9d1056-cc48c28d170fddc2.js  53.4 kB
  └ other shared chunks (total)          1.83 kB


○  (Static)  prerendered as static content
●  (SSG)     prerendered as static HTML (uses getStaticProps)


You can lookat project workspace, there ".next" folder would be have created.
This folder having all production files.

SSG files are found under

.next/server/app/todos
   1.html
   2.html
  etc...

How to test?

npm start
  Which starts production server and deploys app.
.....................................................................................
			 Loading and Streaming
....................................................................................

Loading UI:
 The special file called loading.js helps to create meaningfull loading ui with "React Suspense".
With this convention, you can show an instant loading state from the server while the content of route segment loads, the new content is automaticlly swapped in once rendering is completed.

steps:

1.src/app/dashboard/layout.js
export default function DashboardLayout(props) {
    return <div>
        {props.children}
    </div>
}
2.src/app/dashboard/loading.js
export default function Loading() {
    //you can add UI inside Loading,including a Skeleton
    return <h1>Loading...</h1>
}

3.src/app/dashboard/compoents/greeter.jsx
export default function Greeter(props) {
    return <>
        <h1>Hello</h1>
    </>
}
4.src/app/dashboard/page.js
import React from 'react'

//WelcomeL
const Welcome = React.lazy(() => {
    //return promise
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
})


export default function DashboardPage() {
    return <>
        <Welcome />
    </>
}
Compoent structure:
<Layout>
   <Suspense fallback={<Loading/>}>
     <Page/>
  </Suspense>
...................................................................................
	Putting loading status with in Page: Overriding existing loading.js
...................................................................................

Can we add Loader via Suspense Manually.

Yes, we can add, always local Suspense takes priority.

import React, { Suspense } from 'react'

//WelcomeL
const Welcome = React.lazy(() => {
    //return promise
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
})


export default function DashboardPage() {
    return <>
        <h1>Dashboard page </h1>
        {/* <Welcome/> */}
        <Suspense fallback={<h1>Loading Locally.....</h1>}>
            <Welcome />
        </Suspense>
        <h1>Dashboard page </h1>
        <h1>Dashboard page </h1>
        <h1>Dashboard page </h1>
        <h1>Dashboard page </h1>
        <h1>Dashboard page </h1>

    </>
}
....................................................................................
			  Streaming
....................................................................................
		Streaming
...................................................................................
What is Streaming?
 Before understanding what is streaming, we need to understand how SSR works and its limiatation
 Streaming is going to enchance the SSR limiations.

Steps Involved In SSR:
.....................

1.First , all data for a given page is fetched on the server.

2.The server then renders the HTML page 

3.Once the HTML is ready, the server will send HTML,CSS,javascript for the page are sent to the client.

4.NonInteractive user interface is shown using the generated HTML and CSS In browser

5.Finally React, Hydrates,the user interface to make it interactive


How to measure web site performance?

In order to measure web performance we have some metrics

1.TTFB
2.FCP
3.TTI

TTFB: Time to First Byte:
........................
 Time to First Byte (TTFB) refers to the time between the browser requesting a page and when it receives the first byte of information from the server. This time includes DNS lookup and establishing the connection using a TCP handshake and SSL handshake if the request is made over HTTPS

TTFB is a metric that measures the time between the request for a resource and when the first byte of a response begins to arrive.


FCP :First Contentfull Paint
............................
The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen


TTI:Time to Interactive 

  Time to Interactive (TTI) is a non-standardized web performance 'progress' metric defined as the point in time when the last Long Task finished and was followed by 5 seconds of network and main thread inactivity.

These steps are sequentinal and blocking, meaning that the server only render HTML for a page once all the data has been fetched. 
And on the client side React can only hydrate the UI once the code for all components in the page has been downloaded..

this is traditional process, which degrades the app loading performance
.....................................................................................
		  How to improve loading performance
....................................................................................

SSR with React and Next.js helps improve the perceived loading performance by showing a non interactive page to the user as soon as possible.

Only HTML can be sent once the data fetching is over.


Streaming allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.

This enables part of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.

How to break down into chunks?

  React mental model is component driven, each component we can treat as chunk.

eg:
  if a component have priority or that dont rely on data can be sent first (eg layouts),so the react can hydration eariler....
 if components has less priority, or depends data to be sent later...

How to implement streaming?
 You have to split code into segments

1.static code which does not depend on data
2.dynamic code which depends on data.

if you wrap any component with "Suspense Boundary" which is async, can be rendered later.

if the component relays on data fetching, delays with timers, delays with network connections......

Streaming Component:
....................

export default function Product(props) { 
   <section>
    <nav><a href="product.html"><a></nav>
    <Suspense fallback={<h1>loading....}>
	 <ProductDetails/>
     <Suspense>
   <section>
	
}

Through suspense we can enable streaming....

1.Streaming server rendering: Progressively rendering html from the server to the client

2.Selective Hydration 
    React prioritizes what components to make interactive first based on user interaction.

.....................................................................................
			 Error Handling
....................................................................................

There are two types of errors

1.Page error
  if url is not found, then it throws NotFound.
  not-found.js
2.Application error
  error.js

Introducing Error Boundaries:
	A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”.

	Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed

<ErrorBoundary>
   <MyWidget />
</ErrorBoundary>


The error.js file convention allows you to handle runtime errors in nested routes.

By default Nextjs , wraps your components /pages/layouts within ErrorBoundary only...

if you want to customize the error messages, we can add error.js within the route of app or within nested route.

Create ERROR ui tailored to secific segements using the file system hierarchy to adjust granualrity.

...................................................................................
...................................................................................
				Route Error Handler
....................................................................................

app
 |
 page.js
 layout.js
 dashboard
    |
    page.js
    layout.js
    error.js


error.js
 It automatically creates ReactErrorBoundary that wraps a nested child segment or page compoent
  <Layout>
  
    <ErrorBoundary fallback={<Error/>}
	<Layout>
		<Page/>
        </Layout>
    </ErrorBoundary>
  </Layout>

 error components are "client components"


error.js

'use client'; //Error Component must be client component

export default function Error(props) {
    return <div>
        <h2>Something went Wrong!</h2>
    </div>
}

How to access the error information within error Component?
 The error component has prop


'use client'; //Error Component must be client component

export default function Error(props) {
    console.log(props)
    return <div>
        <h2>Error Page</h2>
        <h3>{props.error.message}</h3>
    </div>
}

Recovery from the errors:

How to recover the errors due to some to network failure...


'use client'; //Error Component must be client component

export default function Error(props) {
    console.log(props)
    return <div>
        <h2>Error Page</h2>
        <h3>{props.error.message}</h3>
        <button onClick={() => {
            props.reset()
        }}>Reset</button>
    </div>
}
.....................................................................................
			How to add Error handler at root
.....................................................................................

		 Errors bubble up
..................................................................................
Errors bubble up to the nearest parent error boundary. This means an error.js file will handle errors for all its nested child segments. More or less granular error UI can be achieved by placing error.js files at different levels in the nested folders of a route.

src/app/error.js
'use client';
import { useEffect } from "react";

//Error Component must be client component

export default function Error(props) {
    //error reporting
    useEffect(() => {
        //log error into error reporting service
        console.error(error)
    }, [props.error])
    console.log(props)
    return <div>
        <h2>Something went wrong</h2>
        <h3>{props.error.message}</h3>
        <button onClick={() => {
            props.reset()
        }}>Try Again</button>
    </div>
}

src/app/page.js
export default function Home() {

  const isValid = true
  if (isValid) {
    throw 'oops'
  }

  return <div>
    <h1>Home Page</h1>
  </div>
}
.....................................................................................
				Not Found Page


if you want to customize the notfound page, you can override the page called "not-found.js"

src/app/not-found.js
import Link from "next/link";

export default function NotFound() {
    return <div>
        <h1>Not Found</h1>
        <p>Could not find requested Resource</p>
        <Link href="/dashboard">Return to Dashboard</Link>
    </div>
}
Testing:
http://localhost:3000/about
....................................................................................
			     SEO - Meta data
....................................................................................
Next js has metadata API that can be used to define your application meta data eg meta and link tas inside HTML head element for imporved SEO and web shareability.

There are two ways you can add metadata to your application

1.config based meta data
    Export a static meta data via obeject called Meta Data Object 
    Dynamic meta data is nothing but getting data from the api and use that data 
    for SEO, We can get dynamic meta data via "generateMetaData Function"

2.File based meta data
    Add static or dynamically generated special files to route segments.

 "With both these options, Next js will automatically generate the relevant <head>   elements for your pages.


1.config based meta data

if you add meta infomration at root level(layout), will be available through out site

static:

src/app/layout.js

import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "TA Digital",
  description: "This is CMS based app",
  creator: "Subramanian Murugan",
  keywords: ["TA Digital", "Next", "React"]
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

2.Dynamic meta data,like web title which need to be filled from api calls.


src/app/posts/page.js

import Link from "next/link";

//meta data
export const metadata = {
    title: 'Post Master Page'
}


export async function fetchPosts() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts')
    const posts = await response.json()
    //here we return promise
    return posts;
}

export default async function PostsPage() {
    const posts = await fetchPosts()
    return <>
        <h1>Posts Master Page</h1>
        {/* Prepare dynamic menu */}
        <ul>
            {
                posts.map(post => {
                    return <li>
                        <Link href={`/posts/${post.id}`}>{post.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}



src/app/posts/[id]/page.js

export async function fetchPosts() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts')
    const posts = await response.json()
    //here we return promise
    return posts;
}


export default function PostsDetailsPage({ params: { id } }) {
    return <div>
        <h1>{id} details</h1>
    </div>
}

//dynamic meta data 

export async function generateMetadata({ params, searchParams }, parent) {
    const id = Number(params.id)
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)
    const post = await response.json()

    //return meta data 
    return {
        title: `Post-${post.id}`
    }

}
.....................................................................................
			Caching,revalidation,ISR
.....................................................................................
How to enable data cache? 

in order to implement we use api which returns current local time, so that we can easily understand how caching is working. 
Api:
 "http://worldtimeapi.org/api/timezone/Asia/Kolkata"

npx create-next-app@latest
√ What is your project named? ... caching-isr
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\session\TADigital\caching-isr.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom
- next


With cache enabled:
...................

src/app/timecache/[city]/page.js

export default async function CachePage(props) {

    //with caching
    const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata')
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

Testing:
http://localhost:3000/timecache/Kolkata

You can notice the time has not changed, because data has been cached.

Without Cache: Cache is disabled:
.................................
export default async function CachePage(props) {

     const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { cache: 'no-store' })
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}
.....................................................................................
			  Caching and Revalidation(clear Cache)
.....................................................................................

Time based Revalidation:

1.Configuration as part of fetch api.

src/app/timecache/[city]/route.js 

export default async function CachePage(props) {
const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { revalidate: 2 } })
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

2.Configuration as part of page vig "Route Segment config"

src/app/timecache/[city]/route.js 

export const revalidate = 2
export default async function CachePage(props) {
 const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata')
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}	



OnDemand Revalidation:
......................

Steps:
1.You have to write rest api , which revalidates cache 
  1.1.You can path 
  1.2.You can use tag 



src/app/timecache/[city]/page.js

//route segment configuration
//export const revalidate = 2

export default async function CachePage(props) {

  const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { tags: ['collection'] } })
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

src/app/api/revalidate/route.js
import { NextResponse } from 'next/server';
import { revalidatePath, revalidateTag } from 'next/cache';

export async function GET(request) {
    //get the path so that we can validate via path
    const path = request.nextUrl.searchParams.get('path') || '/timecache/Kolkata';
    //get the tag so that we can validate via tag
    const collection =
        request.nextUrl.searchParams.get('collection') || 'collection';

    //revalidatePath(path);
    revalidateTag(collection);
    console.log('revalidated', path, collection);
    // console.log('revalidated', path);
    return NextResponse.json({
        revalidated: true,
        now: Date.now(),
        cache: 'no-store',
    });
}

Test:
http://localhost:3000/api/revalidate

after execting this , check the time. whether it has been updated or not.
http://localhost:3000/timecache/Kolkata
...................................................................................
			   ISR 

Incremental Static Rendering is nothing but create pages during build time and cache it, if any data change for the particular page , re render that page, after clearning the cache either by using time based or on demand or both.


ISR = SSG + SSR  =  STATIC Rendering + dynamic Rendering ==build time + request time.

How to implement ISR?

1.Enable cache
2.Select cache revalidation pattern
3.override generateStaticParams method where you have to generate page
  after build time, the page is cached.
4.Revalidate the pre build page using revalidation pattern so that the page is re built.


When you generate page ahead of time using "SSG", during building process also caching is enabled.

Once if the app gone for the production, after that if you want rebuild page you can apply revalidation process. 

ISR  = SSG + Revalidation.


src/app/timecache/[city]/route.js 

Note: you can apply cache revalidatation options either time or OnDemand, in same place you can apply both options.


export default async function CachePage(props) {
    const response = await fetch(`http://worldtimeapi.org/api/timezone/Asia/${props.params.city}`, { next: { tags: ['collection'] } });

    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

export async function generateStaticParams() {
    return [{ city: 'Kolkata' }];
}

src/app/api/revalidate/route.js
import { NextResponse } from 'next/server';
import { revalidatePath, revalidateTag } from 'next/cache';

export async function GET(request) {
    //get the path so that we can validate via path
    const path = request.nextUrl.searchParams.get('path') || '/timecache/Kolkata';
    //get the tag so that we can validate via tag
    const collection =
        request.nextUrl.searchParams.get('collection') || 'collection';

    //revalidatePath(path);
    revalidateTag(collection);
    console.log('revalidated', path, collection);
    // console.log('revalidated', path);
    return NextResponse.json({
        revalidated: true,
        now: Date.now(),
        cache: 'no-store',
    });
}

Testing:
You can opt any revalidation technique (time or ondemand)

http://localhost:3000/timecache/Kolkata

revalidation:
http://localhost:3000/api/revalidate
...................................................................................
			  How to Consume Graphql api inside Next.js
.....................................................................................

Basics of Graphql:

What is Graphql?
Graphql Sepcification
Graphql implemention
  -server implementation -Apollo Server
  -client implementation -next js as client


What is GraphQL?
	GraphQL is a "new API" standard that provides a more efficient, powerful and flexible alternative to REST.


API:
 Appliation programming interface : Entry and exit point for data access.

How apis are represented /encapsulated?
 inside objects

Types of apis:
 1.local api
	api which is part of single runtime- jvm
 2.remote api
       rpc
	 -webservices -  rest api,soap api
         -rpi - grpc
         -tcp based apps
         -smtp based app
       etc...


REST:
   REST has not been designed to be user centric rather than data centric...

if you define any api, which returns data set eg: if you query an api called products

products may have so many fields, i dont want all fields which exposed by the api...

GET  /api/products

 =>[{
  ...
 }]

At its core, GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API.

Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.

GraphQL - A Query Language for APIs

Most applications today have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.

GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense it’s database agnostic and effectively can be used in any context where an API is used.

A more efficient Alternative to REST
....................................

REST has been a popular way to expose data from a server. When the concept of REST was developed, client applications were relatively simple and the development pace wasn’t nearly where it is today. REST thus was a good fit for many applications. However, the API landscape has radically changed over the last couple of years. In particular, there are three factors that have been challenging the way APIs are designed:

1. Increased mobile usage creates need for efficient data loading
Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions.

2. Variety of different frontend frameworks and platforms
The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs.

3. Fast development & expectation for rapid feature development
Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations.

.....................................................................................
			  How to begin with GraphQL


GraphQL is platform and language independant.

GraphQL Can be classified into two category

1.Client side - How to send data(Request) to the GraphQL server.
  in order to send data from the client face book published one spec
  called
   "GraphQL Query language spec"

2.Server side - How to build graph(object tree) from the data sources
    "GraphQL Schema language spec"

.....................................................................................

.....................................................................................
			  GraphQL request and response model.



Declarative Programming:

What you write, you have to get the same structure.

The Query request is more readable,declarative. WHich micics the javascript object literal syntax.

js object:

 let user =  {
     id:1,
     name:'joe'
     friends: [
        'bar','foo'
     ]
  } 

GraphQL Request payload : GraphQL Query

GraphQL Client 

POST /endpoint

  {
     id
     name
     friends { -----------------------------> GraphQLServer
        name
     }
  } 

 {
     id
     name
          -----------------------------> GraphQLServer    
 } 
                        

Response:JSON
 {
     "id":1,
     "name":"joe"
     "friends": [      <----------------------------- GraphQLServer
        "bar","foo"
     ]
  } 
.....................................................................................
			     REST AND CURD

Operations Type

GET ------Read
POST -----CREATE
PUT ------UPDATE
DELETE----Remove

GET /api/products
GET /api/products/1
POST /api/products
PUT /api/products
DELETE /api/products/1
.....................................................................................
				GRAPHQL And CURD


GraphQL uses only URL which exposes Service


  {
     id
     name
     friends { -----------HTTP POST------------------> GraphQLServer
        name
     }
  } 

Operation Types:

1.Query === GET request in HTTP server
  read
2.mutation === HTTP POST,PUT,DELETE
  create,update,delete
3.subscription
   Streaming

query - a read only fetch
mutation- a write followed by read
subscription- a long live request that fetches data in response to source events.

.................................................................................
			 Graphql Query language - Spec
.....................................................................................

Client Side development:
 In this module, we are going to learn how to send request(graphql) request to graphql server..


Syntax:

1.Selection set

selectionSet: {
 Selection
}

Selection:
 fields
 Fragment Spread
 inline fragament


SelectionSet : What type of operations (query,mutation,subscription)

Read:

query  {
    fields
    Fragment Spread
    inline fragament
}

fields: could be what are the data you are expecting from the server
eg:User information 

in the server user information could be many fields
 firstName,lastName,id,age,city,state,status,pic,stars,ranking....

field List :
 You are asking the server that , hey i want only these fields

query  {
   id
   firstName  ====>POST request=========/url===>GraphQLServer==>Execute api
   lastName   <====response would be json
}

Create,Update,Remove: Mutation

mutation createUser(params) { 
  user
}
mutation updateUser(params) { 
  user
}
mutation removeUser(params) { 
  user
}

Streaming: (read with Streaming)

subscription  getStockQuote (params){
  name
  price
  qty
}
.....................................................................................
			  How to learn graphql query language

in order to work with query language we need graphql server, if you dont have local graphql server we can use mock apis

Fake api servers
https://graphqlzero.almansi.me/#example-top
https://countries.trevorblades.com/
 
Tools to test graphql end points
1.Client tools
 playground
 https://www.apollographql.com/docs/apollo-server/v2/testing/graphql-playground/
 postman

Core concepts:
=>fields
=>arguments
=>aliases
=>fragments
=>variables
=>directives
=>Mutations
=>inline fragments

Fiedls:
  At its simplest, GraphQL is about asking for specific fields on objects.

Lets start by looking at a very simple query and the result we get when we run it.
Simple Query:

query {
  countries {
    code
    name
  }
}
query is name of the operation - read 
"countries" is api name from the server   - function countries(){} - returns object-enity

"code,name" are fields (variables)

Simple Query:

query {
  countries {
    code
    name
  }
}
Sample response:
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra"
      },
      {
        "code": "AE",
        "name": "United Arab Emirates"
      },
      {
        "code": "AF",
        "name": "Afghanistan"
      },
      {
        "code": "AG",
        "name": "Antigua and Barbuda"
      },
      {
        "code": "AI",
        "name": "Anguilla"
      },
      {
        "code": "AL",
        "name": "Albania"
      },
      {
        "code": "AM",
        "name": "Armenia"
      },
      {
        "code": "AO",
        "name": "Angola"
      },
      {
        "code": "AQ",
        "name": "Antarctica"
      },
      {
        "code": "AR",
        "name": "Argentina"
      },
      {
        "code": "AS",
        "name": "American Samoa"
      }
]
Short cut:
 we dont need to specificy query keyword
{
  countries {
    code
    name
  }
}
More fields:
 How do we know that the api has more fields?
In the playground, we can see docs in the playground

 {
    countries {
        name
        code
        native
        capital
        currency
    }
}

Inside Graphql server, the above fields are encapulated inside object.
Object property may nest other objects.

How to query nested values?

 {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}

We can use method name syntax
 query getAllCountries {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}
We will see where method syntax is useful.





